'use strict';

var vue = require('vue');
var _ = require('lodash');
var axios = require('axios');
var deepmerge = require('deepmerge');
var moment = require('moment');
var vue$1 = require('@formkit/vue');

const _hoisted_1$x = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 320 512"
};
const _hoisted_2$t = /*#__PURE__*/vue.createElementVNode("path", { d: "M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l192 192c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L77.3 256 246.6 86.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-192 192z" }, null, -1 /* HOISTED */);
const _hoisted_3$n = [
  _hoisted_2$t
];

function render$g(_ctx, _cache) {
  return (vue.openBlock(), vue.createElementBlock("svg", _hoisted_1$x, _hoisted_3$n))
}

const script$A = {};


script$A.render = render$g;
script$A.__file = "src/components/icons/ChevronLeft.vue";

const _hoisted_1$w = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 320 512"
};
const _hoisted_2$s = /*#__PURE__*/vue.createElementVNode("path", { d: "M310.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-192 192c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L242.7 256 73.4 86.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l192 192z" }, null, -1 /* HOISTED */);
const _hoisted_3$m = [
  _hoisted_2$s
];

function render$f(_ctx, _cache) {
  return (vue.openBlock(), vue.createElementBlock("svg", _hoisted_1$w, _hoisted_3$m))
}

const script$z = {};


script$z.render = render$f;
script$z.__file = "src/components/icons/ChevronRight.vue";

const _hoisted_1$v = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 384 512"
};
const _hoisted_2$r = /*#__PURE__*/vue.createElementVNode("path", { d: "M169.4 470.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 370.8 224 64c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 306.7L54.6 265.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z" }, null, -1 /* HOISTED */);
const _hoisted_3$l = [
  _hoisted_2$r
];

function render$e(_ctx, _cache) {
  return (vue.openBlock(), vue.createElementBlock("svg", _hoisted_1$v, _hoisted_3$l))
}

const script$y = {};


script$y.render = render$e;
script$y.__file = "src/components/icons/ArrowDown.vue";

const _hoisted_1$u = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 384 512"
};
const _hoisted_2$q = /*#__PURE__*/vue.createElementVNode("path", { d: "M214.6 41.4c-12.5-12.5-32.8-12.5-45.3 0l-160 160c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L160 141.2V448c0 17.7 14.3 32 32 32s32-14.3 32-32V141.2L329.4 246.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3l-160-160z" }, null, -1 /* HOISTED */);
const _hoisted_3$k = [
  _hoisted_2$q
];

function render$d(_ctx, _cache) {
  return (vue.openBlock(), vue.createElementBlock("svg", _hoisted_1$u, _hoisted_3$k))
}

const script$x = {};


script$x.render = render$d;
script$x.__file = "src/components/icons/ArrowUp.vue";

const _hoisted_1$t = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 512 512"
};
const _hoisted_2$p = /*#__PURE__*/vue.createElementVNode("path", { d: "M441 58.9L453.1 71c9.4 9.4 9.4 24.6 0 33.9L424 134.1 377.9 88 407 58.9c9.4-9.4 24.6-9.4 33.9 0zM209.8 256.2L344 121.9 390.1 168 255.8 302.2c-2.9 2.9-6.5 5-10.4 6.1l-58.5 16.7 16.7-58.5c1.1-3.9 3.2-7.5 6.1-10.4zM373.1 25L175.8 222.2c-8.7 8.7-15 19.4-18.3 31.1l-28.6 100c-2.4 8.4-.1 17.4 6.1 23.6s15.2 8.5 23.6 6.1l100-28.6c11.8-3.4 22.5-9.7 31.1-18.3L487 138.9c28.1-28.1 28.1-73.7 0-101.8L474.9 25C446.8-3.1 401.2-3.1 373.1 25zM88 64C39.4 64 0 103.4 0 152V424c0 48.6 39.4 88 88 88H360c48.6 0 88-39.4 88-88V312c0-13.3-10.7-24-24-24s-24 10.7-24 24V424c0 22.1-17.9 40-40 40H88c-22.1 0-40-17.9-40-40V152c0-22.1 17.9-40 40-40H200c13.3 0 24-10.7 24-24s-10.7-24-24-24H88z" }, null, -1 /* HOISTED */);
const _hoisted_3$j = [
  _hoisted_2$p
];

function render$c(_ctx, _cache) {
  return (vue.openBlock(), vue.createElementBlock("svg", _hoisted_1$t, _hoisted_3$j))
}

const script$w = {};


script$w.render = render$c;
script$w.__file = "src/components/icons/Pencil.vue";

const _hoisted_1$s = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 448 512"
};
const _hoisted_2$o = /*#__PURE__*/vue.createElementVNode("path", { d: "M256 80c0-17.7-14.3-32-32-32s-32 14.3-32 32V224H48c-17.7 0-32 14.3-32 32s14.3 32 32 32H192V432c0 17.7 14.3 32 32 32s32-14.3 32-32V288H400c17.7 0 32-14.3 32-32s-14.3-32-32-32H256V80z" }, null, -1 /* HOISTED */);
const _hoisted_3$i = [
  _hoisted_2$o
];

function render$b(_ctx, _cache) {
  return (vue.openBlock(), vue.createElementBlock("svg", _hoisted_1$s, _hoisted_3$i))
}

const script$v = {};


script$v.render = render$b;
script$v.__file = "src/components/icons/Plus.vue";

const _hoisted_1$r = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 512 512"
};
const _hoisted_2$n = /*#__PURE__*/vue.createElementVNode("path", { d: "M142.9 142.9c62.2-62.2 162.7-62.5 225.3-1L327 183c-6.9 6.9-8.9 17.2-5.2 26.2s12.5 14.8 22.2 14.8H463.5c0 0 0 0 0 0H472c13.3 0 24-10.7 24-24V72c0-9.7-5.8-18.5-14.8-22.2s-19.3-1.7-26.2 5.2L413.4 96.6c-87.6-86.5-228.7-86.2-315.8 1C73.2 122 55.6 150.7 44.8 181.4c-5.9 16.7 2.9 34.9 19.5 40.8s34.9-2.9 40.8-19.5c7.7-21.8 20.2-42.3 37.8-59.8zM16 312v7.6 .7V440c0 9.7 5.8 18.5 14.8 22.2s19.3 1.7 26.2-5.2l41.6-41.6c87.6 86.5 228.7 86.2 315.8-1c24.4-24.4 42.1-53.1 52.9-83.7c5.9-16.7-2.9-34.9-19.5-40.8s-34.9 2.9-40.8 19.5c-7.7 21.8-20.2 42.3-37.8 59.8c-62.2 62.2-162.7 62.5-225.3 1L185 329c6.9-6.9 8.9-17.2 5.2-26.2s-12.5-14.8-22.2-14.8H48.4h-.7H40c-13.3 0-24 10.7-24 24z" }, null, -1 /* HOISTED */);
const _hoisted_3$h = [
  _hoisted_2$n
];

function render$a(_ctx, _cache) {
  return (vue.openBlock(), vue.createElementBlock("svg", _hoisted_1$r, _hoisted_3$h))
}

const script$u = {};


script$u.render = render$a;
script$u.__file = "src/components/icons/Refresh.vue";

const _hoisted_1$q = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 448 512"
};
const _hoisted_2$m = /*#__PURE__*/vue.createElementVNode("path", { d: "M170.5 51.6L151.5 80h145l-19-28.4c-1.5-2.2-4-3.6-6.7-3.6H177.1c-2.7 0-5.2 1.3-6.7 3.6zm147-26.6L354.2 80H368h48 8c13.3 0 24 10.7 24 24s-10.7 24-24 24h-8V432c0 44.2-35.8 80-80 80H112c-44.2 0-80-35.8-80-80V128H24c-13.3 0-24-10.7-24-24S10.7 80 24 80h8H80 93.8l36.7-55.1C140.9 9.4 158.4 0 177.1 0h93.7c18.7 0 36.2 9.4 46.6 24.9zM80 128V432c0 17.7 14.3 32 32 32H336c17.7 0 32-14.3 32-32V128H80zm80 64V400c0 8.8-7.2 16-16 16s-16-7.2-16-16V192c0-8.8 7.2-16 16-16s16 7.2 16 16zm80 0V400c0 8.8-7.2 16-16 16s-16-7.2-16-16V192c0-8.8 7.2-16 16-16s16 7.2 16 16zm80 0V400c0 8.8-7.2 16-16 16s-16-7.2-16-16V192c0-8.8 7.2-16 16-16s16 7.2 16 16z" }, null, -1 /* HOISTED */);
const _hoisted_3$g = [
  _hoisted_2$m
];

function render$9(_ctx, _cache) {
  return (vue.openBlock(), vue.createElementBlock("svg", _hoisted_1$q, _hoisted_3$g))
}

const script$t = {};


script$t.render = render$9;
script$t.__file = "src/components/icons/Trash.vue";

const _hoisted_1$p = {
  xmlns: "http://www.w3.org/2000/svg",
  height: "1em",
  viewBox: "0 0 512 512"
};
const _hoisted_2$l = /*#__PURE__*/vue.createElementVNode("path", { d: "M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM184 232H328c13.3 0 24 10.7 24 24s-10.7 24-24 24H184c-13.3 0-24-10.7-24-24s10.7-24 24-24z" }, null, -1 /* HOISTED */);
const _hoisted_3$f = [
  _hoisted_2$l
];

function render$8(_ctx, _cache) {
  return (vue.openBlock(), vue.createElementBlock("svg", _hoisted_1$p, _hoisted_3$f))
}

const script$s = {};


script$s.render = render$8;
script$s.__file = "src/components/icons/MinusCircle.vue";

const _hoisted_1$o = {
  xmlns: "http://www.w3.org/2000/svg",
  height: "1em",
  viewBox: "0 0 512 512"
};
const _hoisted_2$k = /*#__PURE__*/vue.createElementVNode("path", { d: "M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM232 344V280H168c-13.3 0-24-10.7-24-24s10.7-24 24-24h64V168c0-13.3 10.7-24 24-24s24 10.7 24 24v64h64c13.3 0 24 10.7 24 24s-10.7 24-24 24H280v64c0 13.3-10.7 24-24 24s-24-10.7-24-24z" }, null, -1 /* HOISTED */);
const _hoisted_3$e = [
  _hoisted_2$k
];

function render$7(_ctx, _cache) {
  return (vue.openBlock(), vue.createElementBlock("svg", _hoisted_1$o, _hoisted_3$e))
}

const script$r = {};


script$r.render = render$7;
script$r.__file = "src/components/icons/PlusCircle.vue";

const _hoisted_1$n = {
  xmlns: "http://www.w3.org/2000/svg",
  height: "16",
  width: "16",
  viewBox: "0 0 512 512"
};
const _hoisted_2$j = /*#__PURE__*/vue.createElementVNode("path", { d: "M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM216 336h24V272H216c-13.3 0-24-10.7-24-24s10.7-24 24-24h48c13.3 0 24 10.7 24 24v88h8c13.3 0 24 10.7 24 24s-10.7 24-24 24H216c-13.3 0-24-10.7-24-24s10.7-24 24-24zm40-208a32 32 0 1 1 0 64 32 32 0 1 1 0-64z" }, null, -1 /* HOISTED */);
const _hoisted_3$d = [
  _hoisted_2$j
];

function render$6(_ctx, _cache) {
  return (vue.openBlock(), vue.createElementBlock("svg", _hoisted_1$n, _hoisted_3$d))
}

const script$q = {};


script$q.render = render$6;
script$q.__file = "src/components/icons/InfoCircle.vue";

var script$p = { 
    components: {  ChevronRightIcon: script$z, ChevronLeftIcon: script$A },
    props:{
      pages: {
        type: Number
      },
      actual: {
        type: Number,
        default: 1
      },
    },
    setup(props, { emit }){
      
      const _actual = vue.ref(props.actual);   
      const _pages = vue.ref(props.pages);   

      vue.watch(_pages, (nil) => {
        console.log('novo pages', nil);
      });

      let hasPrev = vue.computed(() => _actual.value > 1);
      let hasNext = vue.computed(() => _actual.value < _pages.value);
      let pageNums = vue.computed(() => {
        let init =  _pages.value > 5; 
        let ends =  _pages.value > 10; 
        let pg = init && ends && _actual.value > 5 && _actual.value < (_pages.value - 5) ? [_actual.value]:[]; 
        return [ ..._.range(1, ( init ? 5:_pages.value)), ...pg, ..._.range( (ends ? (_pages.value - 5):_pages.value), _pages.value)] 
      });
      
      const prev = () => {
        _actual.value = _actual.value > 1 ? (_actual.value - 1) : _actual.value; 
        console.log(
          'prev', typeof _actual.value , 1
        );
        emit('change', _actual.value);
      };

      const next = () => { 
        console.log(
          'next', _actual.value , _pages.value
        );
        _actual.value = _actual.value < _pages.value ? (_actual.value + 1) : _actual.value; 
      
        emit('change', _actual.value);
      };

      const change = (num) => {
        _actual.value = num;
        emit('change', _actual.value);
      };
           
      return {
        change,
        next,
        prev,
        hasPrev,
        hasNext,
        _,
        _actual,
        _pages,
        pageNums
      }
    },
    mounted(){
      this.$watch('pages', () => {
        this._pages = this.pages;
      }, { immediate: true });
    }
  };

const _hoisted_1$m = { "aria-label": "Page navigation" };
const _hoisted_2$i = { class: "flex justify-center list-style-none" };
const _hoisted_3$c = {
  key: 0,
  class: "page-item"
};
const _hoisted_4$8 = { "aria-hidden": "true" };
const _hoisted_5$4 = ["onClick"];
const _hoisted_6$4 = {
  key: 1,
  class: "page-item"
};
const _hoisted_7$2 = {
  "aria-hidden": "true",
  class: "text-md"
};

function render$5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ChevronLeftIcon = vue.resolveComponent("ChevronLeftIcon");
  const _component_ChevronRightIcon = vue.resolveComponent("ChevronRightIcon");

  return (vue.openBlock(), vue.createElementBlock("div", _hoisted_1$m, [
    vue.createElementVNode("ul", _hoisted_2$i, [
      ($setup.hasPrev)
        ? (vue.openBlock(), vue.createElementBlock("li", _hoisted_3$c, [
            vue.createElementVNode("a", {
              class: "page-link relative block py-1.5 px-3 rounded border-0 bg-transparent outline-none transition-all duration-300 rounded text-gray-800 hover:text-gray-800 focus:shadow-none cursor-pointer",
              "aria-label": "Previous",
              onClick: _cache[0] || (_cache[0] = vue.withModifiers((...args) => ($setup.prev && $setup.prev(...args)), ["prevent"]))
            }, [
              vue.createElementVNode("span", _hoisted_4$8, [
                vue.createVNode(_component_ChevronLeftIcon, {
                  class: "h-6 w-6",
                  "aria-hidden": "true"
                })
              ])
            ])
          ]))
        : vue.createCommentVNode("v-if", true),
      (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList($setup.pageNums, (i) => {
        return (vue.openBlock(), vue.createElementBlock("li", {
          class: vue.normalizeClass(["page-item", { 'active': $setup._actual === i }]),
          key: i
        }, [
          vue.createElementVNode("a", {
            class: vue.normalizeClass(["page-link relative block py-1.5 px-3 rounded border-0 outline-none transition-all duration-300 rounded hover:text-gray-800 hover:bg-gray-200 focus:shadow-none cursor-pointer", { 'bg-blue-600 text-white ': $setup._actual === i, 'bg-transparent text-teal-900': $setup._actual != i }]),
            onClick: vue.withModifiers(() => $setup.change(i), ["prevent"])
          }, vue.toDisplayString(i), 11 /* TEXT, CLASS, PROPS */, _hoisted_5$4)
        ], 2 /* CLASS */))
      }), 128 /* KEYED_FRAGMENT */)),
      ($setup.hasNext)
        ? (vue.openBlock(), vue.createElementBlock("li", _hoisted_6$4, [
            vue.createElementVNode("a", {
              class: "page-link relative block py-1.5 px-3 rounded border-0 bg-transparent outline-none transition-all duration-300 rounded text-gray-800 hover:text-gray-800 hover:bg-gray-200 focus:shadow-none cursor-pointer",
              "aria-label": "Next",
              onClick: _cache[1] || (_cache[1] = vue.withModifiers((...args) => ($setup.next && $setup.next(...args)), ["prevent"]))
            }, [
              vue.createElementVNode("span", _hoisted_7$2, [
                vue.createVNode(_component_ChevronRightIcon, {
                  class: "h-6 w-6",
                  "aria-hidden": "true"
                })
              ])
            ])
          ]))
        : vue.createCommentVNode("v-if", true)
    ])
  ]))
}

script$p.render = render$5;
script$p.__file = "src/components/common/Pagination.vue";

var script$o = {
    props:['data', 'cell'],
    data(){ return {
        formopen: false,
        pic: false
    }},
    methods: {
        replaceByDefault(e) {
            e.target.src = '';
        },
        showModal(item){ 
           this.$emit("click", this.data);
           this.pic = item;
           this.formopen = true;
        }
    }
};

const _hoisted_1$l = ["src"];
const _hoisted_2$h = {
  key: 0,
  class: "modal fixed w-full h-full bg-black/20 left-0 top-0"
};
const _hoisted_3$b = { class: "absolute -translate-x-1/2 left-1/2 bg-white p-4 rounded-lg my-2 text center" };
const _hoisted_4$7 = ["src"];

function render$4(_ctx, _cache, $props, $setup, $data, $options) {
  return (vue.openBlock(), vue.createElementBlock("div", null, [
    vue.createElementVNode("img", {
      onClick: _cache[0] || (_cache[0] = $event => ($options.showModal($props.data))),
      src: $props.data,
      style: {"height":"30px","width":"auto"},
      onError: _cache[1] || (_cache[1] = (...args) => ($options.replaceByDefault && $options.replaceByDefault(...args)))
    }, null, 40 /* PROPS, HYDRATE_EVENTS */, _hoisted_1$l),
    ($data.formopen)
      ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_2$h, [
          vue.createElementVNode("div", _hoisted_3$b, [
            vue.createElementVNode("button", {
              onClick: _cache[2] || (_cache[2] = e => $data.formopen = false),
              class: "absolute right-0 top-0"
            }, "âœ–"),
            vue.createElementVNode("img", { src: $data.pic }, null, 8 /* PROPS */, _hoisted_4$7)
          ])
        ]))
      : vue.createCommentVNode("v-if", true)
  ]))
}

script$o.render = render$4;
script$o.__file = "src/components/tables/image.vue";

var script$n = {
    props:['data', 'cell'],
    data(){ return {
        valid: true,
        model: []
    }},
    mounted () {
      this.checkFormat(this.data);
    },
    methods:{
        checkFormat(data){
            if( data === null || data === undefined) 
            this.model = [];
            if( Array.isArray(data) ){
            this.valid = true;
            this.model = data;
            }else if( typeof data == 'string' && data.includes('[') ){
                try {
                    this.model = JSON.parse(data);
                    this.valid = true;
                } catch (e) {
                    this.valid = false;
                }
            }else {
                this.valid = false;
            }
        }
    }
};

const _hoisted_1$k = { key: 0 };
const _hoisted_2$g = { key: 1 };

function render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return (vue.openBlock(), vue.createElementBlock("span", null, [
    ($data.valid)
      ? (vue.openBlock(), vue.createElementBlock("span", _hoisted_1$k, vue.toDisplayString($data.model && $data.model.join(', ')), 1 /* TEXT */))
      : (vue.openBlock(), vue.createElementBlock("span", _hoisted_2$g, "Invalid data array"))
  ]))
}

script$n.render = render$3;
script$n.__file = "src/components/tables/tags.vue";

var script$m = {
    props:['data', 'cell', 'row'],
    methods: {
        replaceContent() {
            if( this.cell?.action?.label ) 
                return _.template(this.cell.action.label)({data: this.data, action: this.cell.action, row: this.row  })
            else
                return this.data
        }
    }
};

const _hoisted_1$j = ["href", "target", "innerHTML"];

function render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return (vue.openBlock(), vue.createElementBlock("a", {
    href: $props.cell?.action?.handler,
    target: ($props.cell?.action?.target ?? '_self'),
    innerHTML: $options.replaceContent()
  }, null, 8 /* PROPS */, _hoisted_1$j))
}

script$m.render = render$2;
script$m.__file = "src/components/tables/link.vue";

const _hoisted_1$i = ["innerHTML"];
  
  
var script$l = {
  __name: 'expression',
  props: ['data', 'cell', 'row'],
  setup(__props) {

const props = __props;
 
  const { template, get } = _;
  
  const { data, cell, row } = props;
  vue.computed(e => { 
      let compiled = _.template(_.get(cell, 'action.template', '${data}'));
      return compiled({data, cell, row}) 
  });

return (_ctx, _cache) => {
  return (vue.openBlock(), vue.createElementBlock("span", {
    innerHTML: vue.unref(template)( vue.unref(get)(vue.unref(cell), 'action.template', '${data}') )(props)
  }, null, 8 /* PROPS */, _hoisted_1$i))
}
}

};

script$l.__file = "src/components/tables/expression.vue";

const { has: has$1, sortBy, get: get$1, isNil: isNil$1, isObject: isObject$1, omit, isEqual, capitalize, round } = _;
 

const mergeDeep  = (a = {}, b = {}) => {
    return deepmerge(a, b, {
        arrayMerge: (d, s) => {
            return [ ...d, ...s ]
        }
    })
};

const getErrorMessage = (error) => {
    if(error){
        if( get$1(error, 'code', '') == "ECONNREFUSED" ){
            return error.message + "( " + get$1(error, 'config.url') + ")"
        }

        if( has$1(error, 'response.data.message') )
            return get$1(error, 'response.data.message')

        if( get$1(error, 'message') )
            return get$1(error, 'message')

        if( typeof error == 'string' )
            return error
    }
    return ""
};

const toRaw = (model) => {
  return JSON.parse( JSON.stringify(model) )
};
 
const formatDate = function(value, format, from, utc=false) {
    if (value) {
      let date = moment(String(value), from);
      // console.log('formatDate', value, date)
      if(utc) date = date.utc();
      return date.format(format)
    }
};

const interpolate = (string, scope, def) => {
    if( typeof string !== 'string' ) return string; 

    return string.replace(/\{([^}]*)}/g, (r,k) => get$1(scope, k, (def ? def:'{'+k+'}')) );
};

const queryString = (params, join, data) => {
    let rtn = '';
    let arrQuery = [];
    if( isObject$1(params) && Object.keys(params).length > 0 ){
        Object.keys(params).map(k => {
            if( Array.isArray(params[k]) )
                params[k].map(i => arrQuery.push([ interpolate(k, data), interpolate(i, data)]) );
            else
                arrQuery.push([interpolate(k, data), interpolate(params[k], data)]);
        });

        rtn = join+new URLSearchParams( arrQuery );
    }
    return rtn
};

const filterParams = (api, queryInfo) => { 
    let { page, pageSize, sort, filters } = queryInfo || {};
    let { params = {}, pagination = {} } = api || {};
    if( !isNil$1(page) && has$1(pagination, 'pageField') )
        params[ pagination.pageField || 'page' ] = page;
    if( !isNil$1(pageSize) && has$1(pagination, 'limitField') )
        params[ pagination.limitField || 'limit'] = pageSize;
    if( sort && !isNil$1(sort.prop) && !isNil$1(sort.order) && has$1(pagination, 'sortField') && has$1(pagination, 'sortExp') ){
        let pagData = {prop: sort.prop, sort: sort.order == 'ascending'? get$1(pagination,'sortAscChar','asc'): get$1(pagination, 'sortDescChar', 'desc')};
        params[ pagination.sortField || 'order' ] = interpolate( get$1(pagination, 'sortExp', '{prop},{order}'), pagData);
    }

    if( get$1(queryInfo, 'filters', []).length > 0 ){
      for(let i = 0; i < get$1(queryInfo, 'filters', []).length; i++ ){  
        let filterField = interpolate(
          get$1(filters[i], 'filterField', (pagination?.filterField || 'filter')), 
          get$1(filters, '[0]', {}) 
        );
        let filterExp = get$1(filters[i], 'filterExp', (pagination?.filterExp || '{prop},like,%{value}%'));
        if ( !params[filterField] ) params[ filterField ] = [];
        if( has$1(filters, `[${i}].prop`) && has$1(filters, `[${i}].value`) && filters[i].value && has$1(pagination, 'filterField') && (has$1(pagination, 'filterExp') || has$1(filters[i], 'filterExp')) )
            params[ filterField ].push( interpolate(filterExp, filters[i]) );
      }
    }else if( has$1(pagination, 'filterField') ){
      let filterField = interpolate(
        get$1(pagination, 'filterField', 'filter'), 
        get$1(filters, '[0]', {}) 
      );
      delete params[ filterField ];
    }
    console.log('filter params', params);
    return {...api, params};
};
  
// const isRegex = (data, reg, custom=false) => {
//     let rgs ={
//         url: "^(http[s]?:\\/\\/(www\\.)?|ftp:\\/\\/(www\\.)?|www\\.)"
//     }
//     if( !rgs[reg] && !custom ) return ;

//     var regex = new RegExp( rgs[reg] || reg );

//     console.debug('isRegex', rgs[reg], data, regex.test(data))
//     return regex.test(data)
// }  


///
// TABLES
//

const schemaColumns = (properties) => {
  // let columns = [ { label: '', key: "_selected", filter: false, sorter:false, sort: -1 } ]
  let columns = [  ];
  let extractdata = (col = {}, k) =>  {
      if( col.children && Array.isArray(col.children) )  col.children.map( i => extractdata(i, k));
      if( get$1(col, 'config.grid', false) )
          columns.push({
              sort: get$1(col, 'config.sort', k+1),
              key: get$1(col, 'name', col.id),
              label: get$1(col, 'config.label', capitalize((col.label || col.name))),
              type: get$1(col, 'config.type', (col.type || 'text')),
              action: Object.assign( get$1(col, 'config.action',{}), get$1(col, 'attributes', {}) ),
              options: get$1(col, 'options', {}),
              model: get$1(col, 'model', {}),
              overwrite: get$1(col, 'overwrite', {}),
              sorter: get$1(col, 'config.sorter', true),
              filter: get$1(col, 'config.filter', true),
              _classes: get$1(col, 'config.classes'),
              _style: get$1(col, 'config.styles'),
          });
  };
  properties.map((col, k) => {
          extractdata(col, k);
  });
 

  return sortBy(columns, ['sort'])
};

const can = (schema, attr, def = true) => {
  return get$1(schema, attr, def)
};

const isSelected = (rows, row) => {
    return rows.findIndex(i => _.isEqual(i, row) ) >= 0
};

const selectionChange = (rows, row, index) => {
    let key = rows.findIndex(i => isEqual(i, row) );
    if( key >= 0 )   
      rows.splice(key, 1);
    else
      rows.push(row);
    return rows
};

const selectionAll = (rows, data) =>{
  if( rows.length == data.length ){
    rows = [];
  }else
    rows = data;
  return rows
};

const fetchQueryInfo = (type, data) => {
  console.debug("fetch query info", type, data);
  let queryInfo = { type };
  if( type == 'sort' ){
    queryInfo.sort = { prop: data.column, order: data.asc === true ? 'ascending':'descending' };
  }
  if( type == 'filter' ){
    queryInfo.filters = Object.keys(data).map((key) => ({ 
      prop: key, value: data[key]?.value, filterExp: data[key]?.filter?.filterExp, filterField: data[key]?.filter?.filterField
    }));
  }
  if( type == 'page' ){
    queryInfo.page = data;
  }
  if( type == 'pageSize' ){
    queryInfo.pageSize = data;
  }
  
 return queryInfo
};

const validateQueryInfo = (queryInfo) => { 
  if( !queryInfo || typeof queryInfo !== 'object' ) return false;
  
  if( ['sizeChange', 'pageSize', 'size', 'pageChange', 'sort', 'filter', 'page', 'init'].includes(queryInfo.type) ){
      if( queryInfo.type == 'filter' &&  !get$1(queryInfo, 'filters[0].prop')  )
          return false;
  }

  return true
};

const calcPages = (totalRows, perPage) => {
  let count = (totalRows || 1) / perPage;
  let rounded = round(count);
  return count > rounded ? rounded + 1 : rounded
};

const normalizeInput = async (row, modifier) => {  
  if( typeof row == 'string' ) return row

  if( row.children && Array.isArray(row.children) )
    for(let idx in row.children){ 
      row.children[idx] = await normalizeInput(row.children[idx], modifier);
    }  

  if( row['$el'] ) return row

  let input = {
    ...row,
    label: _.get(row, 'label', _.capitalize(row?.name ?? '')),
    placeholder: _.get(row, 'placeholder', _.capitalize(row?.name ?? '')),
  };
  if( input['type'] || (!input['$cmp'] && !input['$el'] && !input['type']) ) input['$formkit'] = input.type || 'text';
 
  if( modifier && typeof modifier == 'function') input = await modifier(input);

  return input
};

// FORMS

const schemaFields = (properties) => {
  // let columns = [ { label: '', key: "_selected", filter: false, sorter:false, sort: -1 } ]
  let columns = [  ];
  let extractdata = (col = {}, k) =>  {
      if( col.children && Array.isArray(col.children) )  col.children.map( i => extractdata(i, k));
      if( get$1(col, 'name', false) )
          columns.push({
              sort: get$1(col, 'config.sort', k+1),
              key: get$1(col, 'name', col.id),
              ignored: get$1(col, 'ignore', false),
              label: get$1(col, 'config.label', capitalize((col.label || col.name))),
              type: get$1(col, 'config.type', (col.type || 'text')),
              action: Object.assign( get$1(col, 'config.action',{}), get$1(col, 'attributes', {}) ),
              options: get$1(col, 'options', []),
              model: get$1(col, 'model', {}),
              overwrite: get$1(col, 'overwrite', {}),
              sorter: get$1(col, 'config.sorter', true),
              filter: get$1(col, 'config.filter', true),
              _classes: get$1(col, 'config.classes'),
              _style: get$1(col, 'config.styles'),
          });
  };
  properties.map((col, k) => {
          extractdata(col, k);
  });

  // columns.push({ label: '', key: 'actions', filter: false, sorter: false })

  return sortBy(columns, ['sort'])
};

const { get, set, has, isNil, isEmpty } = _;

var ResourceClass = ({ $axios,  }) => {
  let modelUrl = null;
  let config = {};
  let model = {};
  let schema = [];
  let session = {};
  let sorter = null;
  // table
  let rows = {};
  let total = 1;
 
  // Schema 
  const setConfig = (input) =>{
    config = input;
  };

  const setModel = (modelObj={}) => {
    model = JSON.parse(JSON.stringify(modelObj));
    schema = model.properties;
    config = config?.domain ? config : _.pick(model, ['auth','domain','type','primaryKey']);
  };

  const getModel = () => {
    return model
  };

  const loadModel = (url, options = {}) => {
    return $axios.get(url, options).then(({data}) => {
        console.debug("loadModel "+url, data);
        if( !data ) throw { message: "Model Load error" }

        model = JSON.parse(JSON.stringify(data));
        schema = model.properties;
        return model
    })
  };

  const loadModelByUrl = async (path='', file) => {
    try {
      modelUrl = `/models/${path}${file}`;
      let { data } = await $axios.get(modelUrl);
      if( !data.domain )
        throw { message:'Model load error' }

      model = data;

      return data
    } catch (error) {
      console.error("loadModelByUrl", error);
      return false
    }
  };

  const can = (perm) => {
    if( perm == 'getData' ){
      return get(model, 'api.getData', true)
    }
    if( perm == 'getDataById' ){
      return get(model, 'api.getData', true)
    } 
    if( perm == 'deleteDataById' ){
      return get(model, 'api.deleteDataById', true)
    } 
    if( perm == 'paginate' ){
      return has(model, 'api.pagination.pageField', false)
    } 

    return true
  };

  const isIt = (perm) => {
    if( perm == 'local' ){
      return get(model, 'api.pagination.local', false)
    } 
    if( perm == 'sorter' ){
      return sorter
    }
    if( perm == 'logged' ){
      return get(model, 'auth', false)
    }
    return false
  };

  // Data
  const setData = (resource, filters) => { 
    console.log('setData', resource, filters);
    let data = resource;
    let isRow = has(data, `[${model.primaryKey || 'id'}]`) || model.type == 'form';
    let api = get(model, 'api', {}); 

    if( isRow ){
      return ( !isNil(api.wrapDataById) ? get(data, api.wrapDataById, data): data)
    }else {
      rows = ( !isNil(api.wrapData) ? get(data, api.wrapData, data): data);
      total = ( !isNil(api.totalData) ? get(data, api.totalData, rows.length): rows.length );

      if( !Array.isArray(rows) ) rows = [rows];
      if( typeof total !== 'number' ) total = rows.length;

      if( filters?.filters && Array.isArray(filters?.filters) && filters?.filters?.length > 0 ){
        rows = filterLocal(filters.filters);
        total = rows.length;
      }

      if( !filters?.sort )
        filters.sort = getSchemaSort();
      if( filters?.sort )
        rows = sortLocal(filters.sort);
 
      return {
        rows,
        total
      }
    }
  };

  const getData = (data={}, config={}) => {
    console.log("called get data", data, config);
    let { api = {} } = model;
    if( api.resource && isEmpty(data.data) ) data.data = api.resource;
    let primaryKey = (model?.primaryKey || 'id');

    let url = '';
    let isRow = has(data, `[${model.primaryKey || 'id'}]`) || model.type == 'form';
    let options = {
      method: ( isRow ? ( isNil(api.methodGetById) ? 'GET':api.methodGetById) : (isNil(api.methodGet) ? 'GET':api.methodGet) ),
      ...config
    }; 
    let sessionConfig = {
      session: model.auth
    };

    let query = queryString(api.params, ( api.rootApi.includes('?') ? '&':'?'), data);

    if( isRow )
      url = `${api.rootApi}${ isNil(api.urlGetById) ? '/{'+primaryKey+'}{query}': api.urlGetById }`;
    else
      url = `${api.rootApi}${ isNil(api.urlGet) ? '{query}': api.urlGet }`;

    if( api.headers )
      options['headers'] = api.headers;
    
    url = interpolate(url, {...data, query });
  
    // console.debug('get data', url, options, sessionConfig)
    return $axios(url, options, sessionConfig)
    .then( data => {  
      data = sessionConfig.wrap === false ? data : data.data;

      if( isRow ){
        return ( !isNil(api.wrapDataById) ? get(data, api.wrapDataById, data): data)
      }else {
        rows = ( !isNil(api.wrapData) ? get(data, api.wrapData, data): data);
        total = ( !isNil(api.totalData) ? get(data, api.totalData, rows.length): rows.length );

        if( !Array.isArray(rows) ) rows = [rows];
        if( typeof total !== 'number' ) total = rows.length;
  
        return {
          rows,
          total
        }
      }
    })
  };
  
  const getDataObject = (data={}, config={}) => { 
    let { api = {} } = model;
    if( api.resource && isEmpty(data.data) ) data.data = api.resource;
 
    let url = '';
    let options = {
      method:  isNil(api.methodGet) ? 'GET': api.methodGet,
      ...config
    }; 
    let sessionConfig = {
      session: model.auth
    };

    let query = queryString(api.params, ( api.rootApi.includes('?') ? '&':'?'), data);
  
    url = `${api.rootApi}${ isNil(api.urlGet) ? '{query}':api.urlGet }`;

    if( api.headers )
      options['headers'] = api.headers;
    
    url = interpolate(url, {...data, query });
    
    console.debug('get data object', url, options, sessionConfig);
    return $axios(url, options, sessionConfig)
        .then(({data}) => {   
          return ( !isNil(api.wrapData) ? get(data, api.wrapData, data): data) 
        })
  };
    
  const saveData = async (data, config={}) => { 
    let { api = {} } = model; 
    let resource = api.resource || {};
    let url = '';
    let primaryKey = (isNil(model.primaryKey) ? 'id':model.primaryKey);
    let method = data[primaryKey] ? (isNil(api.methodPatch) ? "PUT":api.methodPatch) : (isNil(api.methodPost) ? "POST":api.methodPost);
    let query = interpolate( 
      queryString(api.params, (api.rootApi.includes('?') ? '&':'?')),  
      { ...data, data: resource }
    );
    let sessionConfig = {
      session: model.auth
    };
  
    if( has(data, primaryKey) && !isNil(data[primaryKey]) )
      url = `${api.rootApi}${ isNil(api.urlPatch) ? '/{id}':api.urlPatch }`;
    else
      url = `${api.rootApi}${ isNil(api.urlPost) ? '': api.urlPost}`;

    console.log("saveData interpolate date", url, {...data, query}, api.resource);
    url = interpolate(url, {...data, query, data: resource});

    let options = {
      method,
      data,
      ...config
    };
    if( api.headers )
      options['headers'] = api.headers;
    
    return $axios(url, options, sessionConfig)
  };

  const deleteData = async (data, config={}) => {
    let { api={} } = model;
    if( api?.resource && isEmpty(data.data) ) data.data = api.resource;
    
    let primaryKey = (model?.primaryKey || 'id');

    if( !has(data, primaryKey) ) return Promise.reject('Id not found')

    let sessionConfig = {
      session: model?.auth
    };
    
    let method = ( isNil(api.methodDelete) ? "DELETE":api.methodDelete );
    let query = interpolate( 
      queryString(api.params, (api.rootApi.includes('?') ? '&':'?')),  
      data
    );
    let url = `${api.rootApi}${ isNil(api.urlDelete) ? '/{id}':api.urlDelete }`;
      
    url = interpolate(url, {...data, query});

    let options = {
      method,
      ...config
    };
    if( api.headers )
      options['headers'] = api.headers;
    
    return $axios(url, options, sessionConfig)
  };

  // Fitlers
  const getSchemaSort = () => {
    return schema.reduce( (pv, i) => {
      if( _.has(i, 'config.sorter') && typeof i.config.sorter == 'string' ){ 
        pv = { prop:i.name, order:i.config.sorter };
      }
      return pv
    }, ({}))
  };

  const paginate = ({ local = false, perPage = 5, page = 1 }) => { 
    console.debug('paginate', rows.length, ((perPage * page) - perPage), (perPage * page));
    if( !local ) return rows
    return  [...rows].slice( ((perPage * page) - perPage), (perPage * page))
  };

  const sorting = ({ local, col, order }) => {
    if( !local ) return rows
    return _.orderBy(rows, col. order)
  };

  const filterLocal = (filters = []) => { 
    return rows.filter(
      (row) => {
        return filters.some(i => String(row[i.prop]).includes(String(i.value)) )
      }
    )
  };

  const sortLocal = (filters) => { 
    console.debug('sortLocal', filters);
    if( !filters || !filters.prop ) return rows

    let sorted = _.sortBy(rows, [filters.prop]);
    sorter = filters.prop;
    if( filters.order === 'descending' ) sorted.reverse();
    return sorted
  };

  // AUTH
  const getSession = () => {
    return session
  };

  const authenticate = ({username, secret, remember}) => {
    try{  
      console.debug('store login'); 

      if( !has(config, 'auth.url_login') ) 
        throw new Error('url login doest exist');
      let input = {
        [get(config, 'auth.field_username', 'email')]: username,
        [get(config, 'auth.field_secret', 'password')]: secret, 
      };
      if( has(config, 'auth.field_remember') )
        input[get(config, 'auth.field_remember', 'remember')] = remember;

      return $axios({
              url: get(config, 'auth.url_login'),
              method: get(config, 'auth.url_method', 'post'),
              data: input,
              headers: get(config, 'api.headers', {}) 
            })
      .then(async (res) => {
          let token = setToken(res);
          let reqAuthData = authRequest(token);
          let user = setUser(res.data);
          session = { request: reqAuthData, logged: true, token, user }; 
          return { token, request: reqAuthData, user, logged: true  }
      })
    }catch(e){ 
      console.error('Resource > authenticate error', e);
      return Promise.reject(e)
    }
  };

  const checkAuth = (force = false) => {
    try{   
      console.debug('Resource > checkAuth start');
      let cfg = _.get(config, 'auth', {});
      let token = getToken(); 
      //Check active session
      if( !token )
        return Promise.reject({message: 'Token not exits'})

      if( _.get(session,'logged') && !force )
        return Promise.resolve(session)

      if( !_.has(cfg, 'logged_url') ){
        return Promise.reject({message: 'Logged url not found'})
      }
      
      let reqAuthData = authRequest(token);
      let url = interpolate( _.get(cfg, 'logged_url'), session);
      
      let options = { 
        url, 
        method: _.get(cfg, 'logged_method', 'get'), 
        ...reqAuthData  
      };

      return $axios(options).then((res) => {
          let user = setUser(res.data);
          
          session = { user, request: reqAuthData, logged: true, token };
          return { token, user, request: reqAuthData, logged: true }
      })
    }catch(e){
      logout();
      console.error('Resource > checkAuth error', e);
      return Promise.reject({message: e.message})
    }
  };

  const getToken = () => { 
    return sessionStorage.getItem(`${_.get(config, 'domain', 'default')}_session`)
  };

  const removeToken = () => { 
    return sessionStorage.removeItem(`${_.get(config, 'domain', 'default')}_session`)
  };

  const setToken = ({data, headers}) => {
    let token = null; 

    let cfg = _.get(config, 'auth', {});
    if( _.get(cfg, 'response_mode', 'body') === 'header' ){
      token = headers[ _.get(cfg, 'response_token', 'access-token') ];
    }else {
      token = _.get(data, _.get(cfg, 'response_token', 'access_token'), null);
    } 

    if( !token ) {
      return new Error ({message: 'token not found', config: cfg, data, headers})
    }

    sessionStorage.setItem(`${_.get(config, 'domain', 'default')}_session`, token);
    return token
  };

  const authRequest = (token) => { 
    let cfg = _.get(config, 'auth', {});

    let tokenRequest = get(cfg, 'request_token_expression', '{token}');
    if( _.get(cfg, 'request_mode', 'header') == 'query' )
      return { 
        headers: _.get(config, 'api.headers', {}),
        params:{
          [_.get(cfg, 'request_token', 'access-token')] : interpolate(tokenRequest, {token})
        }
      } 
    else 
      return {
        headers:{
          ..._.get(config, 'api.headers', {}),
          [_.get(cfg, 'request_token', 'access-token')] : interpolate(tokenRequest, {token})
        }
      }
  };
  
  const setUser = (data) => { 
    let cfg = _.get(config, 'auth', {});
    if( !_.has(cfg, 'logged_model') ) return {};

    let { id, name, username, role } = _.get(cfg, 'logged_model');
    let content = _.get(data, _.get(cfg, 'logged_wrap'), data);
    let user = {
      "id": _.get(content, id, "id"),
      "name": _.get(content, name, "name"),
      "username": _.get(content, username, "email"),
      "role": _.get(content, role, "level")
    };

    return user;
  };

  const logout = async (ctx) => {
    _.get(config, 'auth', {});

    let auth = { logged: false };
    let token = getToken();
    console.log("dispatched logout", token);
    if( token ){   
      removeToken();
    }
    session = auth; 
    return auth
  };

  return {
    // Schema
    loadModel,
    loadModelByUrl,
    setModel,
    getModel,
    can,
    isIt,
    // Data
    setConfig,
    getData,
    setData,
    getDataObject,
    saveData,
    deleteData,
    paginate,
    sorting,
    getSchemaSort,
    // Auth
    getSession,
    getToken,
    setToken,
    authRequest,
    authenticate,
    checkAuth,
    logout,
  }
};

const _hoisted_1$h = ["value"];
const _hoisted_2$f = ["value"];

  
var script$k = {
  __name: 'select',
  props: ['data','cell','row'],
  setup(__props) {

const { data, cell, row } = __props;
 
  
  const Instance = ResourceClass({ $axios:axios });
  const renderComponent = vue.ref(false);
  const loading = vue.ref(false);
  const options = vue.ref([]);
 
  function forceRerender() {
    renderComponent.value = false;

    vue.nextTick(() => {
      renderComponent.value = true;
    });
  }

  async function getOptions({ rootApi, fieldLabel, fieldValue, ...apiModel }, modelValue = {}, filter={}){
    try{ 
      // console.debug("input mixin get options", { rootApi, fieldLabel, fieldValue, ...data })
      if( rootApi ){
        loading.value = true;
        let request = Instance.authRequest( Instance.getToken() );
        apiModel = mergeDeep(apiModel, request);
        if( typeof filter == 'object' )
          apiModel = mergeDeep(apiModel, filter);

        rootApi = interpolate(rootApi, { data:modelValue, row });

        Instance.setModel({ api: { ...apiModel, rootApi, resource:row } });

        // console.log("getOoptions", this.Instance.getModel())
        let { rows } = await Instance.getData({ data:modelValue }); 

        options.value = rows && rows.map((i, k) => ({ 
            label: _.get(i, fieldLabel, i.toString()), 
            value: _.get(i, fieldValue, k)
          }) 
        );
        
        loading.value = false;
        forceRerender();
        return options.value
      }
    }catch(e){
        alert('Erro to get data from '+ rootApi);
        console.error('Erro select input', e);
        return options.value
    }
  } 
    
  vue.onMounted(async () => {
    let { action, model } = cell;
    Instance.setModel(toRaw(model));

    if( _.has(model, 'api.rootApi') )
      cell.options = await getOptions(
          Object.assign(model.api, action), 
          data, 
          filterParams(model.api, { filters:[{prop: action.fieldValue, value:data }] }) 
      );

    renderComponent.value = true;
  }); 

return (_ctx, _cache) => {
  return (renderComponent.value)
    ? (vue.openBlock(), vue.createElementBlock("select", {
        key: 0,
        class: "table-select",
        value: __props.data,
        disabled: ""
      }, [
        vue.createCommentVNode(" v-on=\"$listeners\" "),
        (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList((__props.cell.options || options.value), (opt, idx) => {
          return (vue.openBlock(), vue.createElementBlock("option", {
            key: idx,
            value: opt.value
          }, vue.toDisplayString(opt.label), 9 /* TEXT, PROPS */, _hoisted_2$f))
        }), 128 /* KEYED_FRAGMENT */))
      ], 8 /* PROPS */, _hoisted_1$h))
    : vue.createCommentVNode("v-if", true)
}
}

};

script$k.__file = "src/components/tables/select.vue";

const _hoisted_1$g = {
  key: 0,
  class: "font-semibold text-xs mr-1"
};
const _hoisted_2$e = {
  key: 1,
  class: "font-semibold text-xs ml-1"
};
  
var script$j = {
  __name: 'toggle',
  props: ['data', 'cell', 'row'],
  setup(__props) {

const { data, cell, row } = __props;
 
    
  const model = vue.ref(data ?? false);

return (_ctx, _cache) => {
  return (vue.openBlock(), vue.createElementBlock("div", {
    class: vue.normalizeClass(["flex items-center cursor-pointer py-2", ['cursor-not-allowed']])
  }, [
    (!model.value)
      ? (vue.openBlock(), vue.createElementBlock("span", _hoisted_1$g, " Off "))
      : vue.createCommentVNode("v-if", true),
    vue.createElementVNode("div", {
      class: vue.normalizeClass(["rounded-full w-10 h-6 p-0.5 bg-gray-300", {'bg-red-500': !model.value,'bg-green-500': model.value}])
    }, [
      vue.createElementVNode("div", {
        class: vue.normalizeClass(["rounded-full w-5 h-5 bg-white transform mx-auto duration-300 ease-in-out", {'-translate-x-2': !model.value,'translate-x-2': model.value}])
      }, null, 2 /* CLASS */)
    ], 2 /* CLASS */),
    (model.value)
      ? (vue.openBlock(), vue.createElementBlock("span", _hoisted_2$e, " On "))
      : vue.createCommentVNode("v-if", true)
  ]))
}
}

};

script$j.__file = "src/components/tables/toggle.vue";

const _hoisted_1$f = { class: "whitespace-nowrap" };
  
var script$i = {
  __name: 'dates',
  props: ['data', 'cell', 'row'],
  setup(__props) {

  
    

return (_ctx, _cache) => {
  return (vue.openBlock(), vue.createElementBlock("div", _hoisted_1$f, vue.toDisplayString(vue.unref(formatDate)(__props.data, __props.cell?.action?.format || 'MM/DD/YYYY hh:mm', __props.cell?.action?.from || null, __props.cell?.action?.utc || false)), 1 /* TEXT */))
}
}

};

script$i.__file = "src/components/tables/dates.vue";

const _hoisted_1$e = ["textContent"];
const _hoisted_2$d = ["innerHTML"];
const _hoisted_3$a = ["textContent"];
// import Actions from './action'
// import BelongsTo from './belongsTo'

var script$h = {
  __name: 'index',
  props: ['data','cell'],
  setup(__props) {

const { data, cell } = __props;
  
const { get } = _;
  
vue.computed(() => {
    return get(cell, 'click.type', 'link')
});  

function emitAction(){
    // if( this.cell.type == 'action' || !this.cell.action || !this.cell.action.event || this.cell.action.event != 'click' ) 
    //     return;

    // this.$bus.$emit(this.cell.action?.handler, this.sendType(this.cell, this.data, this.data[this.cell.key]) )
    // console.log("chamado event", this.cell)
}

return (_ctx, _cache) => {
  const _component_CommonsFragment = vue.resolveComponent("CommonsFragment");

  return (__props.cell.type == 'tags')
    ? (vue.openBlock(), vue.createBlock(_component_CommonsFragment, { key: 0 }, {
        default: vue.withCtx(() => [
          vue.createVNode(script$n, {
            data: __props.data[__props.cell.key],
            cell: __props.cell,
            row: __props.data,
            onClick: emitAction
          }, null, 8 /* PROPS */, ["data", "cell", "row"])
        ]),
        _: 1 /* STABLE */
      }))
    : (__props.cell.type == 'image')
      ? (vue.openBlock(), vue.createBlock(_component_CommonsFragment, { key: 1 }, {
          default: vue.withCtx(() => [
            vue.createVNode(script$o, {
              data: __props.data[__props.cell.key],
              cell: __props.cell,
              row: __props.data,
              onClick: emitAction
            }, null, 8 /* PROPS */, ["data", "cell", "row"])
          ]),
          _: 1 /* STABLE */
        }))
      : (__props.cell.type == 'switch' || __props.cell.type == 'toggle')
        ? (vue.openBlock(), vue.createBlock(_component_CommonsFragment, { key: 2 }, {
            default: vue.withCtx(() => [
              vue.createVNode(script$j, {
                data: __props.data[__props.cell.key],
                cell: __props.cell,
                row: __props.data,
                onClick: emitAction
              }, null, 8 /* PROPS */, ["data", "cell", "row"])
            ]),
            _: 1 /* STABLE */
          }))
        : (__props.cell.type == 'select' || __props.cell.type == 'autocomplete' || __props.cell.type == 'dynamic')
          ? (vue.openBlock(), vue.createBlock(_component_CommonsFragment, {
              key: 3,
              onClick: emitAction
            }, {
              default: vue.withCtx(() => [
                vue.createVNode(script$k, {
                  data: __props.data[__props.cell.key],
                  cell: __props.cell,
                  row: __props.data,
                  onClick: emitAction
                }, null, 8 /* PROPS */, ["data", "cell", "row"])
              ]),
              _: 1 /* STABLE */
            }))
          : (__props.cell.type == 'link')
            ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 4 }, [
                vue.createCommentVNode(" <span v-else-if=\"cell.type == 'belongsTo'\">\r\n        <BelongsTo :data=\"data[cell.key]\" :cell=\"cell\" :row=\"data\" v-on:click=\"emitAction\"   />\r\n    </span>  "),
                vue.createVNode(_component_CommonsFragment, null, {
                  default: vue.withCtx(() => [
                    vue.createVNode(script$m, {
                      data: __props.data[__props.cell.key],
                      cell: __props.cell,
                      row: __props.data,
                      onClick: emitAction
                    }, null, 8 /* PROPS */, ["data", "cell", "row"])
                  ]),
                  _: 1 /* STABLE */
                })
              ], 2112 /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */))
            : (__props.cell.type == 'expression')
              ? (vue.openBlock(), vue.createBlock(_component_CommonsFragment, { key: 5 }, {
                  default: vue.withCtx(() => [
                    vue.createVNode(script$l, {
                      data: __props.data[__props.cell.key],
                      cell: __props.cell,
                      row: __props.data,
                      onClick: emitAction
                    }, null, 8 /* PROPS */, ["data", "cell", "row"])
                  ]),
                  _: 1 /* STABLE */
                }))
              : (__props.cell.type == 'date')
                ? (vue.openBlock(), vue.createElementBlock("span", {
                    key: 6,
                    onClick: emitAction
                  }, [
                    vue.createVNode(script$i, {
                      data: __props.data[__props.cell.key],
                      cell: __props.cell,
                      row: __props.data,
                      onClick: emitAction
                    }, null, 8 /* PROPS */, ["data", "cell", "row"])
                  ]))
                : (__props.cell.type == 'object')
                  ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 7 }, [
                      vue.createCommentVNode(" <span v-else-if=\"cell.type == 'action'\"  >\r\n        <Actions :data.sync=\"data[cell.key]\" :cell.sync=\"cell\" :row.sync=\"data\" />\r\n    </span> "),
                      vue.createElementVNode("span", {
                        textContent: vue.toDisplayString(vue.unref(get)(__props.data, `${__props.cell.action.name}`, __props.data[__props.cell.key])),
                        onClick: emitAction
                      }, null, 8 /* PROPS */, _hoisted_1$e)
                    ], 2112 /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */))
                  : (__props.cell.type == 'html')
                    ? (vue.openBlock(), vue.createElementBlock("span", {
                        key: 8,
                        innerHTML: __props.data[__props.cell.key],
                        onClick: emitAction
                      }, null, 8 /* PROPS */, _hoisted_2$d))
                    : (vue.openBlock(), vue.createElementBlock("span", {
                        key: 9,
                        textContent: vue.toDisplayString(__props.data[__props.cell.key]),
                        onClick: emitAction
                      }, null, 8 /* PROPS */, _hoisted_3$a))
}
}

};

script$h.__file = "src/components/tables/index.vue";

const _hoisted_1$d = {
  class: "spinner",
  viewBox: "0 0 50 50"
};
const _hoisted_2$c = /*#__PURE__*/vue.createElementVNode("circle", {
  class: "path",
  cx: "25",
  cy: "25",
  r: "20",
  fill: "none",
  "stroke-width": "5"
}, null, -1 /* HOISTED */);

function render$1(_ctx, _cache) {
  return (vue.openBlock(), vue.createElementBlock("svg", _hoisted_1$d, [
    _hoisted_2$c,
    vue.renderSlot(_ctx.$slots, "default")
  ]))
}

const script$g = {};

script$g.render = render$1;
script$g.__file = "src/components/common/Spinner.vue";

var script$f = {
  __name: 'Alerts',
  props: ['show','message','type'],
  setup(__props) {
   
  

return (_ctx, _cache) => {
  return (__props.show)
    ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: vue.normalizeClass(`alert alert-${__props.type} shadow-lg my-2`)
      }, [
        vue.renderSlot(_ctx.$slots, "default", vue.normalizeProps(vue.guardReactiveProps({ show: __props.show, message: __props.message, type: __props.type })), () => [
          vue.createVNode(vue.unref(script$q), { class: "h-4" }),
          vue.createElementVNode("span", null, vue.toDisplayString(__props.message), 1 /* TEXT */)
        ])
      ], 2 /* CLASS */))
    : vue.createCommentVNode("v-if", true)
}
}

};

script$f.__file = "src/components/common/Alerts.vue";

const _hoisted_1$c = { class: "relative shadow-md sm:rounded-lg crud-table overflow-x-auto w-full" };
const _hoisted_2$b = { class: "text-xs text-gray-700 uppercase bg-gray-50 dark:bg-gray-700 dark:text-gray-400" };
const _hoisted_3$9 = { class: "pd-toolbar py-1" };
const _hoisted_4$6 = ["colspan"];
const _hoisted_5$3 = { class: "headers flex" };
const _hoisted_6$3 = { class: "lelf-col flex items-center justify-left w-1/2" };
const _hoisted_7$1 = { class: "right-col flex items-center justify-center w-1/2" };
const _hoisted_8$1 = { class: "right-col flex items-center justify-end w-1/2" };
const _hoisted_9 = { class: "px-4 flex gap-2" };
const _hoisted_10 = ["checked"];
const _hoisted_11 = ["onClick"];
const _hoisted_12 = { class: "flex items-center gap-2" };
const _hoisted_13 = { key: 0 };
const _hoisted_14 = /*#__PURE__*/vue.createElementVNode("th", { class: "" }, " Â  ", -1 /* HOISTED */);
const _hoisted_15 = {
  key: 0,
  class: "pd-filters"
};
const _hoisted_16 = /*#__PURE__*/vue.createElementVNode("th", { class: "px-4 flex gap-2" }, " Â  ", -1 /* HOISTED */);
const _hoisted_17 = { class: "px-2 flex items-center justify-end" };
const _hoisted_18 = {
  key: 0,
  class: "flex items-center justify-end"
};
const _hoisted_19 = /*#__PURE__*/vue.createElementVNode("p", { class: "" }, "Limit", -1 /* HOISTED */);
const _hoisted_20 = { class: "px-4 py-2" };
const _hoisted_21 = ["checked", "onChange"];
const _hoisted_22 = { class: "px-2 py-2 flex justify-end" };
const _hoisted_23 = ["onClick"];
const _hoisted_24 = ["onClick"];
const _hoisted_25 = {
  key: 0,
  class: "pd-subfooter"
};
const _hoisted_26 = /*#__PURE__*/vue.createElementVNode("td", { class: "px-4 py-2" }, " Â  ", -1 /* HOISTED */);
const _hoisted_27 = { class: "px-2 py-2 flex justify-end" };
const _hoisted_28 = { class: "pd-footer" };
const _hoisted_29 = ["colspan"];
const _hoisted_30 = {
  key: 1,
  class: "text-center h-20"
};
  
  
var script$e = {
  __name: 'Table',
  props: {  
    model:{
      type: Object,
      default: null
    },
    resource: {
      type: Array,
      default: []
    }
  },
  emits: ['create','edit','delete','selected','refresh'],
  setup(__props, { expose: __expose, emit }) {

const { resource, model:defModel } = __props;

  
   
  let model = defModel ? vue.ref(defModel) : vue.inject('model');  
  vue.inject('session');  
  // const App = useAppContext() 
  let Instance = ResourceClass({ $axios: axios }); 
  let alert = vue.ref(null);
  let ready = vue.ref(false);
  let schema = vue.ref([]);
  let filters = vue.ref({});
  let selected = vue.ref([]);
  let table = vue.ref(resource);
  let perPage = vue.ref( _.get(model.value,'api.perPage',5) );
  let tableCount = vue.ref(1);
  vue.reactive({});
  let queryInfo = vue.reactive({});
  const gete = _.get;

  
      
  let totalCols = vue.computed(() => { 
    return schema.value.length + 2
  });
    
  let totalPages = vue.computed(() => { 
    return calcPages(tableCount.value, perPage.value)
  });

  const deleteEmit = (row) =>{
    // Instance.setModel({ ...model.value })

    if( confirm('Are you sure?') ) { 
      ( Instance.can('deleteDataById') ? Instance.deleteData(row):Promise.resolve('bypassed')).then(
        e => {
          console.log(e);
          // $message("Removido com sucesso")
          emit('delete', { target: 'delete', row });
          getDatasource();
        }
      ).catch(setAlert);
    }else {
     return false
    }
  };

  const selectAll = () => {
    selected.value = selectionAll(selected.value, table.value);
    table.value = [ ...table.value ];
  };

  const deleteSelected = async () => {
    if( confirm('Are you sure?') ) {
      for( let row of selected.value ){
        await Instance.deleteData(row).then(e => { 
          emit('delete', { target: 'delete', row});
        });
      }
      $message("Removido com sucesso");
      getDatasource();
    }
  };

  const toggleSort = (col = {}) => {
    vue.nextTick(() => { 
      // let localPagination = _.get(model.value,'api.pagination.local', false)
      // config.sort = col.key
      col._order = _.isNil(col._order) ? false : !col._order;

      queryInfo = { ...queryInfo, ...fetchQueryInfo('sort', { column: col.key, asc: col._order }) };

      console.debug('toggleSort', queryInfo);
      // if( Instance.isIt('local') )
      //   table.value = Instance.sorting({ local: true, col:[col.key], order:[col._order ? 'desc':'asc']  })
      // else
        getDatasource();
    });
  };

  const changePage = (num) => {
    vue.nextTick(() => { 
      let localPagination = _.get(model.value,'api.pagination.local', false);
      queryInfo = { ...queryInfo, ...fetchQueryInfo('page', num) };

      if( localPagination === true )
        table.value = Instance.paginate({ local: true, perPage: perPage.value, page:num });
      else
        getDatasource();
    });
  };

  const changeLimit = (v) => {
    vue.nextTick(() => { 
      if( Instance.can('paginate') )
        queryInfo = { ...queryInfo, ...fetchQueryInfo('pageSize', v) };

      getDatasource();
    });
  };

  const setFilter = (col, value) => {
    return changeFilters({ [col.key]:{ value:value, filter: col?.filter }})
  };

  const changeFilters = (e) => {
    vue.nextTick(() => { 
      console.debug("changeFilters change", e); 
      filters.value = Object.assign(filters.value, e);

      Object.keys(filters.value).map((item) => {
        if( !filters.value[item].value )
           filters.value = _.omit(filters.value, [item]);
      });

      queryInfo = { ...queryInfo, ...fetchQueryInfo('filter', filters.value) };
      getDatasource();
    });
  };

  const getDatasource = async (data={}, config={}) => {
    try {
      if( !Instance.isIt('local') && validateQueryInfo(JSON.parse(JSON.stringify(queryInfo)) )){
        let api = filterParams({ ...model.value.api }, { ...queryInfo, data: resource.value }); 
        Instance.setModel({ ...model.value, api });
      }
 
      if( Instance.can('getData') ){
        var { rows, total } = await Instance.getData(data, config);  
      } else { 
        var { rows, total } = await Instance.setData(resource, queryInfo);  
      }

      if( Instance.isIt('local') ) { 
        var { rows, total } = await Instance.setData(rows, queryInfo);  
      }
       
      // table.value = localPagination ? 
      table.value = Instance.paginate({ local:true, perPage: perPage.value });
      tableCount.value = total;

      emit('refresh', { target:'refresh', rows });
      console.debug("concluiu  getDatasource");
    } catch (error) {
      console.error(error);
      setAlert({ message:"Error to get data", error, type:'error' });
    }
  };

  const modifyColumn = async (input) => {
    if( input.model && typeof input.model == 'string' ) 
      input.model = await Instance.loadModel(input.model);

    if( _.has(model.value, 'auth') ){ 
      let request = Instance.authRequest( Instance.getToken() );
      input.model = mergeDeep(input.model, { api:request });
    } 

    if( input.overwrite && typeof input.overwrite == 'object' )
      input.model = mergeDeep(input.model, input.overwrite);
 
    input.model = mergeDeep(input.model, _.pick(model.value, ['domain','auth']));

    return input
  };

  const setAlert = (rs) => {
    alert.value = {
      message: _.get(rs, 'response.data.message', _.get(rs, 'data.message', rs.message)),
      type: rs && rs.error ? 'error': 'success',
    };
  };

  vue.watch(model, () => {
    Instance.setModel({ ...model.value });

    getDatasource();
  });

  vue.watch(() => selected, (dd) => {  
    emit('selected', { target:'selected', rows:dd.value });
  }, { deep: true });

  __expose({
    getDatasource,
  });

  vue.onBeforeMount(async () => {
    schema.value = schemaColumns(model.value?.properties); 
    for(let idx in schema.value){
      // console.debug('onBeforeMount', schema.value[idx])
      schema.value[idx] = await modifyColumn(schema.value[idx]);
    }
  });
    
  vue.onMounted(async () => {
    try { 
      // console.error("table mounted", model.value)
      Instance.setModel({ ...model.value });
  
      // await getDatasource()
      changeLimit(perPage.value);
      // $bus.listen('table:refresh', getDatasource)
    } catch (error) {
      console.error("onmounted", error);
    }
    ready.value = true;
  });
 
  vue.onUnmounted(() => {
      // console.error("table unmountedmounted", model.value)
      Instance.setModel({ });
  });

return (_ctx, _cache) => {
  const _component_FormKit = vue.resolveComponent("FormKit");

  return (vue.openBlock(), vue.createElementBlock("div", _hoisted_1$c, [
    vue.createVNode(script$f, {
      show: vue.unref(alert)?.message,
      type: vue.unref(alert)?.type,
      message: vue.unref(alert)?.message
    }, {
      default: vue.withCtx(() => [
        vue.renderSlot(_ctx.$slots, "alert", vue.normalizeProps(vue.guardReactiveProps({ alert: vue.unref(alert), model: vue.unref(model), resource: __props.resource })), () => [
          vue.createTextVNode(vue.toDisplayString(vue.unref(alert)?.message), 1 /* TEXT */)
        ])
      ]),
      _: 3 /* FORWARDED */
    }, 8 /* PROPS */, ["show", "type", "message"]),
    (vue.unref(ready))
      ? (vue.openBlock(), vue.createElementBlock("table", {
          key: 0,
          class: vue.normalizeClass(["w-full text-sm text-left text-gray-500 dark:text-gray-400", `${ vue.unref(model).tableClasses || '' }`])
        }, [
          vue.createElementVNode("thead", _hoisted_2$b, [
            vue.createElementVNode("tr", _hoisted_3$9, [
              vue.createElementVNode("th", {
                scope: "col",
                colspan: vue.unref(totalCols),
                class: "py-2"
              }, [
                vue.createElementVNode("div", _hoisted_5$3, [
                  vue.createElementVNode("div", _hoisted_6$3, [
                    (vue.unref(selected).length)
                      ? (vue.openBlock(), vue.createElementBlock("button", {
                          key: 0,
                          class: "px-4 flex items-center whitespace-nowrap",
                          type: "button",
                          onClick: deleteSelected
                        }, [
                          vue.createVNode(vue.unref(script$t), { class: "h-5" }),
                          vue.createTextVNode(" " + vue.toDisplayString(vue.unref(selected).length) + " Selected ", 1 /* TEXT */)
                        ]))
                      : vue.createCommentVNode("v-if", true),
                    vue.createElementVNode("button", {
                      class: "px-4",
                      type: "button",
                      onClick: getDatasource
                    }, [
                      vue.createVNode(vue.unref(script$u), { class: "h-5" })
                    ]),
                    (vue.unref(can)(vue.unref(model), 'canCreate'))
                      ? (vue.openBlock(), vue.createElementBlock("button", {
                          key: 1,
                          class: "px-4",
                          type: "button",
                          onClick: _cache[0] || (_cache[0] = () => emit('create', {target: 'create', row: {}}))
                        }, [
                          vue.createVNode(vue.unref(script$v), { class: "h-5" })
                        ]))
                      : vue.createCommentVNode("v-if", true),
                    vue.renderSlot(_ctx.$slots, "toolbar-left")
                  ]),
                  vue.createElementVNode("div", _hoisted_7$1, [
                    vue.renderSlot(_ctx.$slots, "toolbar-center")
                  ]),
                  vue.createElementVNode("div", _hoisted_8$1, [
                    vue.renderSlot(_ctx.$slots, "toolbar-right")
                  ])
                ])
              ], 8 /* PROPS */, _hoisted_4$6)
            ]),
            vue.createElementVNode("tr", null, [
              vue.createElementVNode("th", _hoisted_9, [
                vue.createElementVNode("input", {
                  type: "checkbox",
                  checked: (vue.unref(selected).length == vue.unref(table).length),
                  onChange: selectAll
                }, null, 40 /* PROPS, HYDRATE_EVENTS */, _hoisted_10),
                vue.createTextVNode(" All ")
              ]),
              (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(vue.unref(schema), (col) => {
                return (vue.openBlock(), vue.createElementBlock("th", {
                  scope: "col",
                  class: "px-2 py-1",
                  key: col.key,
                  onClick: () => toggleSort(col)
                }, [
                  vue.createElementVNode("div", _hoisted_12, [
                    vue.createTextVNode(vue.toDisplayString(col.label) + " ", 1 /* TEXT */),
                    (col.sorter && vue.unref(Instance).isIt('sorter') == col.key)
                      ? (vue.openBlock(), vue.createElementBlock("span", _hoisted_13, [
                          (col._order)
                            ? (vue.openBlock(), vue.createBlock(vue.unref(script$x), {
                                key: 0,
                                class: "h-4"
                              }))
                            : (vue.openBlock(), vue.createBlock(vue.unref(script$y), {
                                key: 1,
                                class: "h-4"
                              }))
                        ]))
                      : vue.createCommentVNode("v-if", true)
                  ])
                ], 8 /* PROPS */, _hoisted_11))
              }), 128 /* KEYED_FRAGMENT */)),
              _hoisted_14
            ]),
            (vue.unref(can)(vue.unref(model), 'api.pagination.limitField', false) && vue.unref(can)(vue.unref(model), 'api.pagination.filterExp', false))
              ? (vue.openBlock(), vue.createElementBlock("tr", _hoisted_15, [
                  _hoisted_16,
                  (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(vue.unref(schema), (col) => {
                    return (vue.openBlock(), vue.createElementBlock("th", {
                      scope: "col",
                      class: "px-2",
                      key: col.key
                    }, [
                      (vue.unref(can)(vue.unref(model), 'api.pagination.filterExp', false) && col.filter)
                        ? (vue.openBlock(), vue.createBlock(_component_FormKit, {
                            key: 0,
                            type: vue.unref(gete)(col, 'filter.type', 'search'),
                            delay: 500,
                            "outer-class": "m-0 p-0",
                            "input-class": "w-full p-1",
                            model: vue.unref(gete)(col, 'model', {}),
                            overwrite: vue.unref(gete)(col, 'overwrite', {}),
                            options: vue.unref(gete)(col, 'options', []),
                            onInput: e => setFilter(col, e)
                          }, null, 8 /* PROPS */, ["type", "model", "overwrite", "options", "onInput"]))
                        : vue.createCommentVNode("v-if", true),
                      vue.renderSlot(_ctx.$slots, "header-scope", vue.normalizeProps(vue.guardReactiveProps({col, filters: vue.unref(filters)})))
                    ]))
                  }), 128 /* KEYED_FRAGMENT */)),
                  vue.createElementVNode("th", _hoisted_17, [
                    vue.renderSlot(_ctx.$slots, "header-actions", vue.normalizeProps(vue.guardReactiveProps({schema: vue.unref(schema), filters: vue.unref(filters)}))),
                    (vue.unref(can)(vue.unref(model), 'api.pagination.limitField', false))
                      ? (vue.openBlock(), vue.createElementBlock("span", _hoisted_18, [
                          _hoisted_19,
                          vue.createVNode(_component_FormKit, {
                            "outer-class": "m-0 p-0 pl-2",
                            "input-class": "text-xs",
                            type: "select",
                            modelValue: vue.unref(perPage),
                            "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => (vue.isRef(perPage) ? (perPage).value = $event : perPage = $event)),
                            options: [1,5,15,25,50,100,500],
                            onInput: changeLimit
                          }, null, 8 /* PROPS */, ["modelValue"])
                        ]))
                      : vue.createCommentVNode("v-if", true)
                  ])
                ]))
              : vue.createCommentVNode("v-if", true)
          ]),
          vue.createElementVNode("tbody", null, [
            (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(vue.unref(table), (row, index) => {
              return (vue.openBlock(), vue.createElementBlock("tr", {
                class: "pd-rows bg-white border-b dark:bg-gray-800 dark:border-gray-700",
                key: index
              }, [
                vue.createElementVNode("td", _hoisted_20, [
                  vue.createElementVNode("input", {
                    type: "checkbox",
                    value: false,
                    checked: vue.unref(isSelected)(vue.unref(selected), row),
                    onChange: $event => (vue.unref(selectionChange)(vue.unref(selected), row))
                  }, null, 40 /* PROPS, HYDRATE_EVENTS */, _hoisted_21)
                ]),
                (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(vue.unref(schema), (col, k) => {
                  return (vue.openBlock(), vue.createElementBlock("td", {
                    class: "px-2 py-2",
                    key: col.key
                  }, [
                    vue.renderSlot(_ctx.$slots, "row-scope", vue.normalizeProps(vue.guardReactiveProps({col, row, index})), () => [
                      (vue.openBlock(), vue.createBlock(script$h, {
                        cell: col,
                        data: row,
                        key: col.key+k
                      }, null, 8 /* PROPS */, ["cell", "data"]))
                    ])
                  ]))
                }), 128 /* KEYED_FRAGMENT */)),
                vue.createElementVNode("td", _hoisted_22, [
                  vue.renderSlot(_ctx.$slots, "row-actions", vue.normalizeProps(vue.guardReactiveProps({row, index}))),
                  (vue.unref(can)(vue.unref(model), 'canEdit'))
                    ? (vue.openBlock(), vue.createElementBlock("a", {
                        key: 0,
                        class: "cursor-pointer mr-3",
                        onClick: () => emit('edit', { target: 'edit', row})
                      }, [
                        vue.createVNode(vue.unref(script$w), { class: "h-5" })
                      ], 8 /* PROPS */, _hoisted_23))
                    : vue.createCommentVNode("v-if", true),
                  (vue.unref(can)(vue.unref(model), 'canDelete'))
                    ? (vue.openBlock(), vue.createElementBlock("a", {
                        key: 1,
                        class: "cursor-pointer",
                        onClick: () => deleteEmit(row)
                      }, [
                        vue.createVNode(vue.unref(script$t), { class: "h-5" })
                      ], 8 /* PROPS */, _hoisted_24))
                    : vue.createCommentVNode("v-if", true)
                ])
              ]))
            }), 128 /* KEYED_FRAGMENT */))
          ]),
          vue.createElementVNode("tfoot", null, [
            (vue.unref(can)(vue.unref(model), 'canFooter', false))
              ? (vue.openBlock(), vue.createElementBlock("tr", _hoisted_25, [
                  _hoisted_26,
                  (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(vue.unref(schema), (col) => {
                    return (vue.openBlock(), vue.createElementBlock("td", {
                      class: "px-4 py-2",
                      key: col.key
                    }, [
                      vue.renderSlot(_ctx.$slots, "footer-scope", vue.normalizeProps(vue.guardReactiveProps({col, table: vue.unref(table), filters: vue.unref(filters)})))
                    ]))
                  }), 128 /* KEYED_FRAGMENT */)),
                  vue.createElementVNode("td", _hoisted_27, [
                    vue.renderSlot(_ctx.$slots, "footer-actions", vue.normalizeProps(vue.guardReactiveProps({table: vue.unref(table), filters: vue.unref(filters)})))
                  ])
                ]))
              : vue.createCommentVNode("v-if", true),
            vue.createElementVNode("tr", _hoisted_28, [
              vue.createElementVNode("td", {
                colspan: vue.unref(totalCols),
                class: "w-full pt-4"
              }, [
                vue.renderSlot(_ctx.$slots, "pagination", vue.normalizeProps(vue.guardReactiveProps({totalPages: vue.unref(totalPages), actual:1, changePage: changePage})), () => [
                  (vue.unref(can)(vue.unref(model), 'api.pagination.pageField', false) || vue.unref(can)(vue.unref(model), 'api.pagination.local', false))
                    ? (vue.openBlock(), vue.createBlock(script$p, {
                        key: 0,
                        pages: vue.unref(totalPages),
                        actual: 1,
                        onChange: changePage
                      }, null, 8 /* PROPS */, ["pages"]))
                    : vue.createCommentVNode("v-if", true)
                ])
              ], 8 /* PROPS */, _hoisted_29)
            ])
          ])
        ], 2 /* CLASS */))
      : (vue.openBlock(), vue.createElementBlock("div", _hoisted_30, [
          vue.createVNode(script$g)
        ]))
  ]))
}
}

};

script$e.__file = "src/components/Table.vue";

const _hoisted_1$b = {
  key: 0,
  class: "form"
};
const _hoisted_2$a = { key: 1 };
const _hoisted_3$8 = { key: 2 };

  // let { $axios, $bus, $message } = useNuxtApp() 
  
var script$d = {
  __name: 'Form',
  props: {
    model: {
      type: Object,
      default: () => ({ properties: [] })
    }, 
    data: {
      type: Object,
      default: () => ({})
    },
    resource:{
      type: Object,
      default: () => ({})
    },
  },
  emits: ['saved','created'],
  setup(__props, { emit }) {

const { model, data, resource } = __props;

  let Instance = ResourceClass({ $axios: axios });
  
  // const App = useAppContext()
  // const Auth = useAuth() 
  const schema = vue.ref([]); 

  
 
  const save = (payload) => {
    Instance.setModel(JSON.parse(JSON.stringify(model))); 
    let formFields = fields.value.filter(i => !i.ignored).map(i => i.key);
    // console.debug('Save', formFields, payload)  
    Instance.saveData(_.pick(payload, formFields)).then((rs) => {
      // $message("Saved ")
      res.value = { message: _.get(rs, 'data.message', 'Success saved'), type:'success'  };
      emit('saved', rs);

      // emit('form:created', rs)
    }).catch(err => {
      console.error('Saved error', err);
      res.value = { message: _.get(err, 'response.data.message', err.message), type:'error' };
    });
  };

  let row = vue.ref(data);
  let res = vue.ref({});
  let ready = vue.ref(false);
  let fields = vue.ref(schemaFields(model?.properties)); 
 
  const getDatasource = async (payload={}, config={}) => {
    try { 
      console.debug("chamou to formDatasource", model);  
      let api = filterParams({ ..._.get(model, 'api', {}) }, { data: payload }); 

      Instance.setModel({ ...model, api });

      row.value = await Instance.getDataObject(payload, config);  
      console.debug("concluiu  getDatasource", api);
    } catch (error) {
      console.error('error formDatarousce', error);
      res.value = Object.assign(error, {type:'error'});
    }
  };

  vue.watch(model, (newVal) => {
    // console.debug('form wathc', newVal)
    Instance.setModel(JSON.parse(JSON.stringify(newVal))); 
  });
  
  const modifyInput = async (input) => {
    if( input.model && typeof input.model == 'string' ) 
      input.model = await Instance.loadModel(input.model);
      
    let token = Instance.getToken();
    let request = Instance.authRequest(token); 
    _.set(input.model, 'api.resource', row.value);
    _.set(input.model, 'api', mergeDeep(_.get(input.model,'api',({})), request) );

    return input
  };
 
  vue.onBeforeMount(async () => {
    try {  
      let modelRaw = JSON.parse(JSON.stringify(model));
      Instance.setModel(modelRaw);
      fields.value = schemaFields(modelRaw.properties);
      // row.value = await Instance.getData(row.value)
 
      // Instance.setModel(model.value)
      // resource.value = await Instance.getData() 

      // console.debug('fields', fields.value)
      for(let row of model.properties){ 
        schema.value.push( await normalizeInput(row, modifyInput) );
      } 
    } catch (error) {
      console.error("onBeforeMount error", error);
    }
  });

  vue.onMounted(async () => {
    if( model.type == 'form' && Instance.can('getDataById') )
        await getDatasource(resource);
    
    ready.value = true;
  });

  vue.onUnmounted(() => { 
    console.debug("onUnmounted");
  });

return (_ctx, _cache) => {
  const _component_FormKitSchema = vue.resolveComponent("FormKitSchema");
  const _component_FormKit = vue.resolveComponent("FormKit");

  return (!!vue.unref(row))
    ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_1$b, [
        vue.createVNode(script$f, {
          show: vue.unref(res)?.message,
          message: vue.unref(res)?.message,
          type: vue.unref(res)?.type
        }, {
          default: vue.withCtx(() => [
            vue.renderSlot(_ctx.$slots, "alert", vue.normalizeProps(vue.guardReactiveProps({ row: vue.unref(row), res: vue.unref(res), model: __props.model })), () => [
              vue.createTextVNode(vue.toDisplayString(vue.unref(res).message), 1 /* TEXT */)
            ])
          ]),
          _: 3 /* FORWARDED */
        }, 8 /* PROPS */, ["show", "message", "type"]),
        (vue.unref(ready) && schema.value)
          ? (vue.openBlock(), vue.createBlock(_component_FormKit, {
              key: 0,
              type: "form",
              method: "post",
              "submit-label": "Submit",
              "form-class": `w-full ${ __props.model?.formClasses || '' }`,
              actions: vue.unref(can)(__props.model, 'submit'),
              modelValue: vue.unref(row),
              "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => (vue.isRef(row) ? (row).value = $event : row = $event)),
              onSubmit: save
            }, {
              default: vue.withCtx(() => [
                vue.renderSlot(_ctx.$slots, "prefix", vue.normalizeProps(vue.guardReactiveProps({ row: vue.unref(row), res: vue.unref(res), model: __props.model }))),
                vue.createVNode(_component_FormKitSchema, {
                  schema: schema.value,
                  class: "py-2"
                }, null, 8 /* PROPS */, ["schema"]),
                vue.renderSlot(_ctx.$slots, "suffix", vue.normalizeProps(vue.guardReactiveProps({ row: vue.unref(row), res: vue.unref(res), model: __props.model })))
              ]),
              _: 3 /* FORWARDED */
            }, 8 /* PROPS */, ["form-class", "actions", "modelValue"]))
          : (!vue.unref(ready))
            ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_2$a, [
                vue.createVNode(script$g)
              ]))
            : (vue.openBlock(), vue.createElementBlock("div", _hoisted_3$8, [
                vue.renderSlot(_ctx.$slots, "error", vue.normalizeProps(vue.guardReactiveProps({ row: vue.unref(row), res: vue.unref(res), model: __props.model })), () => [
                  vue.createTextVNode(" Schema not found ")
                ])
              ]))
      ]))
    : vue.createCommentVNode("v-if", true)
}
}

};

script$d.__file = "src/components/Form.vue";

const _hoisted_1$a = {
  key: 0,
  class: "modal fixed w-full h-full bg-black/20 left-0 top-0"
};
const _hoisted_2$9 = { class: "absolute w-1/2 -translate-x-1/2 left-1/2 bg-white p-4 rounded-lg my-2 max-h-[95vh] overflow-y-auto" };


var script$c = {
  __name: 'Flow',
  props: ['schema'],
  setup(__props) {

const { schema } = __props;

 
vue.ref(schema); 
const data =  vue.ref();

function setData (newVal) {
  data.value = null;
  vue.nextTick(() => {
    data.value = newVal;
  });
}

function doEvent(e){
  // console.log( 'Event received', JSON.stringify(e, null, 2))
  if( e.target == 'create' )
    setData(e.row);
  if( e.target == 'edit' )
    setData(e.row); 
}

return (_ctx, _cache) => {
  return (vue.openBlock(), vue.createElementBlock("main", {
    class: vue.normalizeClass(`w-full relative ${ _ctx.$attrs.class || ''}`)
  }, [
    vue.createVNode(script$e, {
      model: __props.schema,
      onCreate: doEvent,
      onEdit: doEvent,
      onDelete: doEvent,
      onSelected: doEvent,
      onRefresh: doEvent
    }, null, 8 /* PROPS */, ["model"]),
    (data.value)
      ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_1$a, [
          vue.createElementVNode("button", {
            onClick: _cache[0] || (_cache[0] = e => setData(null)),
            class: "absolute right-0"
          }, "âœ–"),
          vue.createElementVNode("div", _hoisted_2$9, [
            vue.createVNode(script$d, {
              model: __props.schema,
              data: data.value,
              onSaved: _cache[1] || (_cache[1] = $event => (setData(null)))
            }, null, 8 /* PROPS */, ["model", "data"])
          ])
        ]))
      : vue.createCommentVNode("v-if", true)
  ], 2 /* CLASS */))
}
}

};

script$c.__file = "src/components/Flow.vue";

function render(_ctx, _cache) {
  return vue.renderSlot(_ctx.$slots, "default")
}

const script$b = {};


script$b.render = render;
script$b.__file = "src/components/common/Fragment.vue";

const _hoisted_1$9 = { key: 0 };
const _hoisted_2$8 = {
  key: 1,
  class: "auth-form w-full md:w-1/3 m-auto"
};
const _hoisted_3$7 = {
  key: 0,
  class: "text-center"
};
const _hoisted_4$5 = /*#__PURE__*/vue.createElementVNode("h4", { class: "text-center py-4" }, "Project Authentication", -1 /* HOISTED */);
const _hoisted_5$2 = { class: "action-buttons mt-3 flex gap-4" };
const _hoisted_6$2 = ["disabled"];

  
var script$a = {
  __name: 'Auth',
  props: ['schema', 'config'],
  emits: ['auth:failed','auth:logged','update:schema'],
  setup(__props, { emit }) {

const { schema, config = {} } = __props;
 
  const Instance = ResourceClass({ $axios: axios });
  
  

  let loading = vue.ref(true);
  let form = vue.ref({});
  let login = vue.ref(false);
  let session = vue.ref({});
  let alerts = vue.ref({});
  Instance.setModel(schema);  
  Instance.setConfig(config);  
 
  let hasAuth = vue.computed(() => {
    return _.has(config, 'auth')
  }); 
  
  const doAuth = async (form) => {
    try{
      loading.value = true;
      let res = await Instance.authenticate(form);
      
      return await Instance.checkAuth(true).then(success).catch(error)
    }catch(e){
      console.error( getErrorMessage(e) ); 
      loading.value = false;
    }
  };

  const success = function(res){ 
    console.debug("called success", res);
    session.value = res;
    alerts.value = { message: _.get(res, 'data.message', res.statusText), type:'success'  };

    if( !_.has(session.value, 'token') ) {
      loading.value = false;
      return emit('auth:failed', {message: 'token not found', ...res })
    } 
     
    emit(
      'update:schema', 
      mergeDeep(schema, { api: _.get(session.value, 'request', {}) })
    );
    emit('auth:logged', _.pick(session.value, ['token','user','logged']));

    vue.nextTick(() => {
      loading.value = false;
      login.value = true;
    });
  };
  
  const error = function({ response, message, ...data }){
    // app.message( getErrorMessage({ response, message, ...data }) )
    console.log('Auth Error', message, response, data);
    loading.value = false;
    login.value = false;
    alerts.value = { message: _.get(response, 'data.message', message), type:'error'  };
    
    emit('auth:failed', {message});
  };

  const logout = () => {
    console.debug("called auth logout");
    loading.value = true;
    return Instance.logout().then(() => {
      loading.value = false;
      login.value = false;
      console.debug("finish auth logout");
    })
  };  
      
  vue.onMounted(async () => {
    try{  
      if( !hasAuth.value || !Instance.isIt('logged') ) {
        console.debug('bypassed auth', hasAuth.value, Instance.isIt('logged') );
        login.value = true;  
        loading.value = false; 
        return;
      }

      console.debug('auth process start');
      let token = Instance.getToken();
      session.value = Instance.getSession(); 

      loading.value = true;
      if( token && _.get(session.value, 'logged', false) ){
        // emit('auth:logged', session.value)  
        success(session.value);
      }else if( token ){
        await Instance.checkAuth().then(success);
      }else { 
        login.value = false;
        console.debug('show login form'); 
      } 
      
      loading.value = false; 
    }catch(e){
      login.value = false;
      emit('auth:failed', e);
      console.debug('erro mounted auth', e);
      console.error( getErrorMessage(e) );
      
      loading.value = false; 
    }  
  }); 

return (_ctx, _cache) => {
  const _component_Alerts = vue.resolveComponent("Alerts");
  const _component_FormKit = vue.resolveComponent("FormKit");

  return (vue.openBlock(), vue.createBlock(script$b, null, {
    default: vue.withCtx(() => [
      vue.createVNode(_component_Alerts, {
        show: vue.unref(alerts)?.message,
        message: vue.unref(alerts)?.message,
        type: vue.unref(alerts)?.type
      }, null, 8 /* PROPS */, ["show", "message", "type"]),
      (vue.unref(login))
        ? (vue.openBlock(), vue.createElementBlock("section", _hoisted_1$9, [
            vue.renderSlot(_ctx.$slots, "default", {
              schema: __props.schema,
              methods: { logout: logout },
              session: vue.unref(session)
            }, () => [
              vue.createTextVNode(" vazio ")
            ])
          ]))
        : (vue.openBlock(), vue.createElementBlock("section", _hoisted_2$8, [
            (vue.unref(loading))
              ? (vue.openBlock(), vue.createElementBlock("h3", _hoisted_3$7, [
                  vue.createVNode(script$g, null, {
                    default: vue.withCtx(() => [
                      vue.createTextVNode(">Authenticating...")
                    ]),
                    _: 1 /* STABLE */
                  })
                ]))
              : (vue.openBlock(), vue.createBlock(_component_FormKit, {
                  key: 1,
                  type: "form",
                  "form-class": "flex flex-col gap-4",
                  method: "post",
                  modelValue: vue.unref(form),
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => (vue.isRef(form) ? (form).value = $event : form = $event)),
                  onSubmit: doAuth,
                  actions: false
                }, {
                  default: vue.withCtx(({ hasErrors }) => [
                    _hoisted_4$5,
                    vue.createVNode(_component_FormKit, {
                      type: "text",
                      name: "username",
                      placeholder: "Username",
                      validation: "required"
                    }),
                    vue.createVNode(_component_FormKit, {
                      type: "password",
                      name: "secret",
                      placeholder: "Password",
                      validation: "required"
                    }),
                    vue.createVNode(_component_FormKit, {
                      type: "checkbox",
                      name: "remember",
                      label: "Keep logged",
                      wrapperClass: "flex gap-2",
                      innerClass: "w-6"
                    }),
                    vue.createElementVNode("div", _hoisted_5$2, [
                      vue.createElementVNode("button", {
                        type: "button",
                        color: "danger",
                        class: "py-2 px-4 border bg-red-800 text-white rounded hover:text-gray-400",
                        onClick: _cache[0] || (_cache[0] = $event => (_ctx.$emit('close', { refresh: false })))
                      }, " Cancel "),
                      vue.createElementVNode("button", {
                        type: "submit",
                        color: "success",
                        class: "py-2 px-4 border bg-green-800 text-white rounded hover:text-gray-400",
                        disabled: hasErrors
                      }, " Send ", 8 /* PROPS */, _hoisted_6$2)
                    ])
                  ]),
                  _: 1 /* STABLE */
                }, 8 /* PROPS */, ["modelValue"]))
          ]))
    ]),
    _: 3 /* FORWARDED */
  }))
}
}

};

script$a.__file = "src/components/Auth.vue";

const _hoisted_1$8 = { class: "tabs" };
const _hoisted_2$7 = { class: "flex my-2 w-full border-b" };
const _hoisted_3$6 = ["onClick"];

  
var script$9 = {
  __name: 'Tabs',
  props: ['tab', 'tabs'],
  setup(__props) {

const { tabs:tabes , tab } = __props;
  
    
  const tabs = vue.ref(tabes); 
  const active = vue.ref(''); 
  let styleTag = vue.reactive(); 
		
  function changeTab(tb){
    if( tabs.value?.length === 0 ) return ;

    active.value = tb.name;

    if( styleTag ) styleTag.remove();

    const css = `
      ${ tabs.value.map(i => i.name).join(',') }{
        display: none;
      } 
      ${tb.name}{
        ${ tb.enabledStyle ? `${ tb.enabledStyle } ${ tb.enabledStyle.includes('important') ?'':'!important' }` : 'display: flex; flex-direction: column;' }
      }
    `;
    styleTag = document.createElement('style');
    styleTag.appendChild(document.createTextNode(css));
    document.head.appendChild(styleTag);
  }  
  
  vue.onMounted(() => {
		if( tabs.value?.length === 0 ) return ;

		changeTab(tabs.value[0]);
		active.value = tabs.value[0].name;
  });

  vue.onBeforeUnmount(() => {
    styleTag.remove();
  }); 

return (_ctx, _cache) => {
  return (vue.openBlock(), vue.createElementBlock("section", _hoisted_1$8, [
    vue.createElementVNode("ul", _hoisted_2$7, [
      (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(tabs.value, (tb, ky) => {
        return (vue.openBlock(), vue.createElementBlock("li", {
          class: "mr-2 -mb-px",
          key: ky
        }, [
          vue.createElementVNode("a", {
            onClick: $event => (changeTab(tb)),
            href: "#",
            class: vue.normalizeClass([{'active': active.value == tb.name }, "inline-block py-2 px-4 text-blue-500 hover:text-blue-800 font-semibold"])
          }, vue.toDisplayString(tb.label), 11 /* TEXT, CLASS, PROPS */, _hoisted_3$6)
        ]))
      }), 128 /* KEYED_FRAGMENT */))
    ])
  ]))
}
}

};

script$9.__file = "src/components/common/Tabs.vue";

var script$8 = {
  __name: 'Section',
  props: ['model','resource'],
  setup(__props) {

const { model, resource:res = [] } = __props;
  
  let Instance = ResourceClass({ $axios:axios });

  
  const ready = vue.ref(false);
  const schema = vue.ref([{'$el':'h1', 'children':'Hello World'}]);
  let resource = vue.reactive(res);
  
  async function loadData () { 
    let res = await Instance.getData().catch(console.error);
    resource = JSON.parse(JSON.stringify(res));
  }

  vue.onBeforeMount(async () => { 
    try{
      if( typeof model === 'string' ){
        let data = await Instance.loadModel(model); 
        if( data.api?.rootApi )
          await loadData();
        schema.value = data; 
      }else {
        Instance.setModel(model);
        if( model?.api?.rootApi )
          await loadData();
        schema.value = model;
      } 
      ready.value = true;
    } catch(e) {
      console.error('before mont', e);
    }
  });
 
  vue.onMounted(async () => { 
    console.log('mounted section', typeof model); 
  });

return (_ctx, _cache) => {
  const _component_FormKitSchema = vue.resolveComponent("FormKitSchema");

  return (ready.value)
    ? (vue.openBlock(), vue.createBlock(script$b, { key: 0 }, {
        default: vue.withCtx(() => [
          vue.createVNode(_component_FormKitSchema, {
            schema: schema.value?.properties || schema.value,
            data: vue.unref(resource)
          }, null, 8 /* PROPS */, ["schema", "data"])
        ]),
        _: 1 /* STABLE */
      }))
    : vue.createCommentVNode("v-if", true)
}
}

};

script$8.__file = "src/components/layouts/Section.vue";

const _hoisted_1$7 = { key: 1 };
  
  
var script$7 = {
  __name: 'Forms',
  props: ['model','resource'],
  setup(__props) {

const { model, resource:res = {} } = __props;
   
   

  const ready = vue.ref(false);
  let schema = vue.ref({ });
  let resource = vue.reactive(res);
  let Instance = ResourceClass({ $axios:axios });
  
  vue.onBeforeMount(async () => { 
    try{
      if( typeof model === 'string' ){
        let data = await Instance.loadModel(model);  
        schema.value = data; 
      }else {
        Instance.setModel(model); 
        schema.value = model;
      } 
      ready.value = true;
    } catch(e) {
      console.error('before mont', e);
    }
  });
 
 
  vue.onMounted(async () => { 
    // ready.value = true
  });

return (_ctx, _cache) => {
  const _component_CrudForm = vue.resolveComponent("CrudForm");

  return (ready.value)
    ? (vue.openBlock(), vue.createBlock(script$b, { key: 0 }, {
        default: vue.withCtx(() => [
          (vue.unref(schema).properties)
            ? (vue.openBlock(), vue.createBlock(_component_CrudForm, {
                key: 0,
                model: vue.unref(schema),
                data: vue.unref(resource),
                onSaved: _cache[0] || (_cache[0] = e =>_ctx.$emit('saved', e))
              }, null, 8 /* PROPS */, ["model", "data"]))
            : (vue.openBlock(), vue.createElementBlock("span", _hoisted_1$7, "Properties required"))
        ]),
        _: 1 /* STABLE */
      }))
    : vue.createCommentVNode("v-if", true)
}
}

};

script$7.__file = "src/components/layouts/Forms.vue";

var components = {
  Table: script$e,
  Form: script$d,
  Flow: script$c,
  Tabs: script$9,
  Auth: script$a,
  Section: script$8,
  Forms: script$7,
};

const _hoisted_1$6 = ["data-type"];
const _hoisted_2$6 = { class: "flex flex-col py-2" };
const _hoisted_3$5 = { class: "py-2" };
const _hoisted_4$4 = /*#__PURE__*/vue.createElementVNode("hr", null, null, -1 /* HOISTED */);
 
  
var script$6 = {
  __name: 'grid',
  props: ['context'],
  emits: ['create'],
  setup(__props, { emit }) {

const { context } = __props;

   
   
  const props = vue.computed(() => context.node?.props || {});  

  const model = vue.ref({
    ..._.get(props.value, 'model', {}),
    canCreate: _.get(props.value, 'model.canEdit', false),
    canEdit: _.get(props.value, 'model.canEdit', false),
    canDelete: _.get(props.value, 'model.canEdit', false),
  }); 
  const selected = vue.ref([]); 
  
  function changed({rows}) { 
    console.log('change', rows);
    selected.value = rows;
    context.node.input(rows);
  }

  function hook({ target, ...data }){ 
    if( target == 'create' && context.attrs.onCreate )
      context.attrs.onCreate({ target, ...data });
    if( target == 'edit' && context.attrs.onEdit )
      context.attrs.onEdit({ target, ...data });
    if( target == 'delete' && context.attrs.onDelete )
      context.attrs.onDelete({ target, ...data });
    if( target == 'refresh' && context.attrs.onRefresh )
      context.attrs.onRefresh({ target, ...data });
  }

  vue.onMounted(() => {
    console.log('grid', context.attrs.onCreate);
    
  });

return (_ctx, _cache) => {
  return (vue.openBlock(), vue.createElementBlock("div", {
    "data-type": __props.context.type,
    class: vue.normalizeClass([props.value.outerClass ?? ''])
  }, [
    vue.createElementVNode("div", _hoisted_2$6, [
      vue.createVNode(script$e, {
        resource: [],
        model: model.value,
        onSelected: changed,
        onCreate: hook,
        onEdit: hook,
        onDelete: hook,
        onRefresh: hook
      }, null, 8 /* PROPS */, ["model"]),
      vue.createElementVNode("p", _hoisted_3$5, "Selected: " + vue.toDisplayString(selected.value.length), 1 /* TEXT */)
    ]),
    _hoisted_4$4
  ], 10 /* CLASS, PROPS */, _hoisted_1$6))
}
}

};

script$6.__file = "src/components/inputs/grid.vue";

const _hoisted_1$5 = ["data-type"];
const _hoisted_2$5 = { class: "flex flex-col py-2" };
const _hoisted_3$4 = /*#__PURE__*/vue.createElementVNode("hr", null, null, -1 /* HOISTED */);
  
  
var script$5 = {
  __name: 'subform',
  props: ['context'],
  setup(__props) {

const { context } = __props;

   
  const props = vue.computed(() => context.node?.props || {});  

  const model = vue.ref( props.value?.model ); 
  const selected = vue.ref([]); 
  const resource = vue.computed(() => model.value.api?.resource || {});  
  
  function changed(rows) { 
    selected.value = rows;
    context.node.input(rows);
  }

  vue.onMounted(() => { 
    
  });

return (_ctx, _cache) => {
  return (vue.openBlock(), vue.createElementBlock("div", {
    "data-type": __props.context.type,
    class: vue.normalizeClass([props.value.outerClass ?? ''])
  }, [
    vue.createElementVNode("div", _hoisted_2$5, [
      (vue.openBlock(), vue.createBlock(script$d, {
        key: __props.context.node.name,
        data: __props.context.value,
        resource: resource.value,
        model: model.value,
        onSaved: changed
      }, null, 8 /* PROPS */, ["data", "resource", "model"]))
    ]),
    _hoisted_3$4
  ], 10 /* CLASS, PROPS */, _hoisted_1$5))
}
}

};

script$5.__file = "src/components/inputs/subform.vue";

const _hoisted_1$4 = ["data-type"];
const _hoisted_2$4 = /*#__PURE__*/vue.createElementVNode("span", { class: "font-semibold text-xs mr-1" }, " Off ", -1 /* HOISTED */);
const _hoisted_3$3 = /*#__PURE__*/vue.createElementVNode("span", { class: "font-semibold text-xs ml-1" }, " On ", -1 /* HOISTED */);
const _hoisted_4$3 = {
  key: 2,
  class: "formkit-messages"
};
  
var script$4 = {
  __name: 'toggle',
  props: ['context'],
  setup(__props) {

const { context } = __props;
 
   
  const props = vue.computed(() => context.node?.props || {});
  const model = vue.ref(context.value ?? false);

  function setValue (value) { 
    if( context.attrs?.readonly ) return;

    model.value = !model.value;
    context.node.input(model.value);
  } 

return (_ctx, _cache) => {
  return (vue.openBlock(), vue.createElementBlock("div", {
    class: vue.normalizeClass(["formkit-outer", [props.value.outerClass ?? '']]),
    "data-type": __props.context.type
  }, [
    (__props.context.label)
      ? (vue.openBlock(), vue.createElementBlock("span", {
          key: 0,
          class: vue.normalizeClass(["formkit-label", [props.value.labelClass ?? '']])
        }, vue.toDisplayString(__props.context.label), 3 /* TEXT, CLASS */))
      : vue.createCommentVNode("v-if", true),
    vue.createElementVNode("div", {
      class: vue.normalizeClass(["formkit-wrapper flex items-center cursor-pointer py-2", [props.value.wrapperClass ?? '', __props.context.attrs?.readonly ? 'cursor-not-allowed':'']]),
      onClick: setValue
    }, [
      _hoisted_2$4,
      vue.createElementVNode("div", {
        class: vue.normalizeClass(["rounded-full w-10 h-6 p-0.5 bg-gray-300", {'bg-red-500': !model.value,'bg-green-500': model.value}])
      }, [
        vue.createElementVNode("div", {
          class: vue.normalizeClass(["rounded-full w-5 h-5 bg-white transform mx-auto duration-300 ease-in-out", {'-translate-x-2': !model.value,'translate-x-2': model.value}])
        }, null, 2 /* CLASS */)
      ], 2 /* CLASS */),
      _hoisted_3$3
    ], 2 /* CLASS */),
    (__props.context.help)
      ? (vue.openBlock(), vue.createElementBlock("span", {
          key: 1,
          class: vue.normalizeClass(["formkit-help", [props.value.helpClass ?? '']])
        }, vue.toDisplayString(__props.context.help), 3 /* TEXT, CLASS */))
      : vue.createCommentVNode("v-if", true),
    (_ctx.hasMessages)
      ? (vue.openBlock(), vue.createElementBlock("ul", _hoisted_4$3, [
          (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(__props.context.messages, (msg) => {
            return (vue.openBlock(), vue.createElementBlock("li", {
              class: "formkit-message",
              key: msg.key
            }, vue.toDisplayString(msg.value), 1 /* TEXT */))
          }), 128 /* KEYED_FRAGMENT */))
        ]))
      : vue.createCommentVNode("v-if", true)
  ], 10 /* CLASS, PROPS */, _hoisted_1$4))
}
}

};

script$4.__file = "src/components/inputs/toggle.vue";

const _hoisted_1$3 = ["data-type"];
const _hoisted_2$3 = {
  key: 0,
  class: "tag-input"
};
const _hoisted_3$2 = ["onClick"];
const _hoisted_4$2 = ["onKeydown"];
const _hoisted_5$1 = { key: 1 };
const _hoisted_6$1 = {
  key: 2,
  class: "formkit-messages"
};
  
var script$3 = {
  __name: 'tags',
  props: ['context'],
  setup(__props) {

const { context } = __props;
 
   
  const props = vue.computed(() => context.node?.props || {});
  const valid = vue.ref(true);
  const model = vue.ref([]);
  
  function checkFormat(data){
    if( data === null || data === undefined ) {
      model.value = [];  
      valid.value = true;
    } else if( typeof data == 'string' ) {
        try { 
          model.value = JSON.parse(data);
          valid.value = true;
        } catch (e) {
            valid.value = false;
        }
    } else {
        valid.value = false;
    }
  }
  function addTag (event) {
      event.preventDefault();
      var val = event.target.value.trim();
      if (val.length > 0) {
        model.value.push(val);
        event.target.value = '';
        changeData(model.value);
      }
  }
  function removeTag (index) {
      model.value.splice(index, 1);
      changeData(model.value);
  }
  function removeLastTag(event) {
      if (event.target.value.length === 0) {
        removeTag(model.value.length - 1);
        
        changeData(model.value);
      }
  }
  function changeData(data){ 
    if( context.output && context.output == 'json')
      context.node.input(JSON.stringify(data));
    else
      context.node.input(data); 
  }

  vue.onMounted(() => {
    checkFormat(context.value);
  });

return (_ctx, _cache) => {
  return (vue.openBlock(), vue.createElementBlock("div", {
    class: vue.normalizeClass(["formkit-outer", [props.value.outerClass ?? '']]),
    "data-type": __props.context.type
  }, [
    (__props.context.label)
      ? (vue.openBlock(), vue.createElementBlock("span", {
          key: 0,
          class: vue.normalizeClass(["formkit-label", [props.value.labelClass ?? '']])
        }, vue.toDisplayString(__props.context.label), 3 /* TEXT, CLASS */))
      : vue.createCommentVNode("v-if", true),
    vue.createElementVNode("section", {
      class: vue.normalizeClass(["formkit-wrapper", [props.value.wrapperClass ?? '']])
    }, [
      (valid.value)
        ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_2$3, [
            (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(model.value, (tag, index) => {
              return (vue.openBlock(), vue.createElementBlock("div", {
                key: index,
                class: "tag-input__tag"
              }, [
                vue.createElementVNode("span", {
                  onClick: $event => (removeTag(index))
                }, "x", 8 /* PROPS */, _hoisted_3$2),
                vue.createTextVNode(" " + vue.toDisplayString(tag), 1 /* TEXT */)
              ]))
            }), 128 /* KEYED_FRAGMENT */)),
            vue.createElementVNode("input", vue.mergeProps({ type: "text" }, __props.context.attributes, {
              placeholder: "Type + Enter",
              class: "tag-input__text",
              onKeydown: [
                vue.withKeys(addTag, ["enter"]),
                vue.withKeys(addTag, ["188"]),
                vue.withKeys(removeLastTag, ["delete"])
              ]
            }), null, 16 /* FULL_PROPS */, _hoisted_4$2)
          ]))
        : vue.createCommentVNode("v-if", true),
      (!valid.value)
        ? (vue.openBlock(), vue.createElementBlock("p", _hoisted_5$1, "Invalid data"))
        : vue.createCommentVNode("v-if", true)
    ], 2 /* CLASS */),
    (__props.context.help)
      ? (vue.openBlock(), vue.createElementBlock("span", {
          key: 1,
          class: vue.normalizeClass(["formkit-help", [props.value.helpClass ?? '']])
        }, vue.toDisplayString(__props.context.help), 3 /* TEXT, CLASS */))
      : vue.createCommentVNode("v-if", true),
    (_ctx.hasMessages)
      ? (vue.openBlock(), vue.createElementBlock("ul", _hoisted_6$1, [
          (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(__props.context.messages, (msg) => {
            return (vue.openBlock(), vue.createElementBlock("li", {
              class: "formkit-message",
              key: msg.key
            }, vue.toDisplayString(msg.value), 1 /* TEXT */))
          }), 128 /* KEYED_FRAGMENT */))
        ]))
      : vue.createCommentVNode("v-if", true)
  ], 10 /* CLASS, PROPS */, _hoisted_1$3))
}
}

};

script$3.__scopeId = "data-v-342edb1f";
script$3.__file = "src/components/inputs/tags.vue";

const _hoisted_1$2 = ["data-type"];
const _hoisted_2$2 = {
  key: 0,
  class: "relative"
};
const _hoisted_3$1 = { class: "flex py-2 gap-2" };
const _hoisted_4$1 = ["onClick"];
const _hoisted_5 = /*#__PURE__*/vue.createElementVNode("hr", null, null, -1 /* HOISTED */);
const _hoisted_6 = {
  key: 1,
  class: "relative"
};
const _hoisted_7 = { key: 2 };
const _hoisted_8 = {
  key: 2,
  class: "formkit-messages"
};
  
var script$2 = {
  __name: 'repeater',
  props: ['context'],
  setup(__props) {

const { context = {} } = __props;
  
   
  const props = vue.computed(() => context.node?.props || {});
  vue.ref(true);
  const schema = vue.ref([]);
  const model = vue.ref([]); 
  const rendered = vue.ref(false);
  const schemaObj = vue.computed(() => {
    if( props.value.inline ) return []
    else
      return model.value.map((i, k) => {
        return {
          "$formkit": "group",
          "name": k,  
          "children": [
            {
              "$el": "div",
              "attrs": {"class":"flex py-2 gap-2"},
              "children":[
                {
                  "$el": "div",
                  "attrs": {"class":"w-full"},
                  "children": schema.value
                },
                {
                  "$el":'button',
                  "attrs":{ "type":"button", "class":"p-2", "onclick":() => removeTag(k) },
                  "children": [
                    {
                      "$cmp": script$s,
                      "props": { "class": "h-5", "title":"Remove item" }
                    } 
                  ]
                },
              ]
            },
            {
              "$el": "hr",
              "attrs": {"class":"w-full p-1"},
              "children":""
            }
          ]
        }
      })
  });  
  
  function addTag (event) { 
    var val = props.value.inline === true ? "":({ }); 
    // model.value.push(val)  
    context.node.input([...context.value, val]);  
    model.value = [...context.value, val];
  }

  function removeTag (index) {  
    let data = JSON.parse(JSON.stringify(model.value));
    data = data.filter((i, k) => k != index);
    context.node.input(data);  
    model.value = data;
  }
 
  vue.onMounted(async () => {  
    model.value = [...context.value];
    for(let row of (props.value.schema || []) ){ 
      schema.value.push( await normalizeInput(row) );
    } 
    rendered.value = true;
  });

return (_ctx, _cache) => {
  const _component_FormKit = vue.resolveComponent("FormKit");
  const _component_FormKitSchema = vue.resolveComponent("FormKitSchema");

  return (vue.openBlock(), vue.createElementBlock("div", {
    class: vue.normalizeClass(["formkit-outer", [props.value.outerClass ?? '']]),
    "data-type": __props.context.type
  }, [
    (__props.context.label)
      ? (vue.openBlock(), vue.createElementBlock("span", {
          key: 0,
          class: vue.normalizeClass(["formkit-label", [props.value.labelClass ?? '']])
        }, vue.toDisplayString(__props.context.label), 3 /* TEXT, CLASS */))
      : vue.createCommentVNode("v-if", true),
    vue.createElementVNode("section", {
      class: vue.normalizeClass(["formkit-wrapper", [props.value.wrapperClass ?? '']])
    }, [
      (schema.value && rendered.value && props.value.inline === true)
        ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_2$2, [
            (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(__props.context.value, (row, i) => {
              return (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: i }, [
                vue.createElementVNode("div", _hoisted_3$1, [
                  (![null,undefined].includes(model.value[i]))
                    ? (vue.openBlock(), vue.createBlock(_component_FormKit, vue.mergeProps({ key: 0 }, vue.unref(_).omit(schema.value[0], ['$formkit']), {
                        modelValue: model.value[i],
                        "onUpdate:modelValue": $event => ((model.value[i]) = $event)
                      }), null, 16 /* FULL_PROPS */, ["modelValue", "onUpdate:modelValue"]))
                    : vue.createCommentVNode("v-if", true),
                  vue.createElementVNode("button", {
                    type: "button",
                    class: "flex justify-between items-center gap-2 p-2",
                    onClick: $event => (removeTag(i)),
                    title: "Remove item"
                  }, [
                    vue.createVNode(vue.unref(script$s), { class: "h-5" })
                  ], 8 /* PROPS */, _hoisted_4$1)
                ]),
                _hoisted_5
              ], 64 /* STABLE_FRAGMENT */))
            }), 128 /* KEYED_FRAGMENT */))
          ]))
        : (schema.value && rendered.value && !props.value.inline)
          ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_6, [
              vue.createVNode(_component_FormKitSchema, { schema: schemaObj.value }, null, 8 /* PROPS */, ["schema"])
            ]))
          : (vue.openBlock(), vue.createElementBlock("span", _hoisted_7, "error"))
    ], 2 /* CLASS */),
    vue.createElementVNode("button", {
      type: "button",
      class: "flex justify-start items-center gap-2 py-2",
      onClick: addTag,
      title: "Add new item"
    }, [
      vue.createVNode(vue.unref(script$r), { class: "h-5" }),
      vue.createTextVNode(" Add ")
    ]),
    (__props.context.help)
      ? (vue.openBlock(), vue.createElementBlock("span", {
          key: 1,
          class: vue.normalizeClass(["formkit-help", [props.value.helpClass ?? '']])
        }, vue.toDisplayString(__props.context.help), 3 /* TEXT, CLASS */))
      : vue.createCommentVNode("v-if", true),
    (_ctx.hasMessages)
      ? (vue.openBlock(), vue.createElementBlock("ul", _hoisted_8, [
          (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(__props.context.messages, (msg) => {
            return (vue.openBlock(), vue.createElementBlock("li", {
              class: "formkit-message",
              key: msg.key
            }, vue.toDisplayString(msg.value), 1 /* TEXT */))
          }), 128 /* KEYED_FRAGMENT */))
        ]))
      : vue.createCommentVNode("v-if", true)
  ], 10 /* CLASS, PROPS */, _hoisted_1$2))
}
}

};

script$2.__file = "src/components/inputs/repeater.vue";

const _hoisted_1$1 = ["data-type"];
const _hoisted_2$1 = {
  key: 0,
  class: "prefix p-2"
};
const _hoisted_3 = {
  key: 1,
  class: "suffix p-2"
};
const _hoisted_4 = {
  key: 2,
  class: "formkit-messages"
};
  
var script$1 = {
  __name: 'currency',
  props: ['context'],
  setup(__props) {

const { context } = __props;
 
   
  const props = vue.computed(() => context.node?.props || {});
  const slots = vue.computed(() => props.value?.slots || {});
  const field = vue.ref();
  vue.ref([]);
  
  const formataMoedaInput = () => {
    field.value = formatarMoeda(field.value);
    
    context.node.input( unformat(field.value) );
  };
  
  const formatarMoeda = (valor) => {
    valor = valor + '';
    valor = parseInt( valor.replace(/[\D]+/g, '') );
    valor = valor + '';
    valor = valor.replace(/[\D]+/g, '');
    valor = valor.replace(/([0-9]{2})$/g, ',$1');
    
    if (valor.length === 3) valor = '0'+valor;
    else if (valor.length === 1) valor = '0,0'+valor;
    
    if( valor.length > 6 )
      valor = valor.replace(/([0-9]{3}),([0-9]{2}$)/g, ".$1,$2");
    if( valor.length > 10 )
      valor = valor.replace(/([0-9]{3}),([0-9]{3}),([0-9]{2}$)/g, ".$1.$2,$3");
    if( valor.length > 14 )
      valor = valor.replace(/([0-9]{3}),([0-9]{3}),([0-9]{3}),([0-9]{2}$)/g, ".$1.$2.$3,$4"); 
    if( valor == 'NaN' ) return ''
    
    return valor
  };
  
  const unformat = (valor) => {
    valor = valor + '';
    valor = valor.replace(/[^0-9,]+/g, ''); 
    valor = valor.replace(',', '.'); 
    return (valor === NaN || valor == 'NaN') ? '' : +valor
  };
  
  const parseNumber = (valor = '0') => {
    const splitValor = (valor + '').split('.');
    
    if( !splitValor[1] ) ;
    else if (splitValor[1].length === 1) valor += '0';
    
    return valor+''.replace(/\D/g, '') || 0
  };
  
  vue.watch(() => context.value, (newVal, oldVal) => {
     if( newVal && unformat(field.value) !== newVal ){
       field.value = parseNumber(newVal);
       field.value = formatarMoeda(field.value);
     }
  });
  
  vue.onMounted(() => {
    field.value = parseNumber(context.value); 
  });

return (_ctx, _cache) => {
  return (vue.openBlock(), vue.createElementBlock("div", {
    class: vue.normalizeClass(["formkit-outer", [props.value.outerClass ?? '']]),
    "data-type": __props.context.type
  }, [
    (__props.context.label)
      ? (vue.openBlock(), vue.createElementBlock("span", {
          key: 0,
          class: vue.normalizeClass(["formkit-label", [props.value.labelClass ?? '']])
        }, vue.toDisplayString(__props.context.label), 3 /* TEXT, CLASS */))
      : vue.createCommentVNode("v-if", true),
    vue.createElementVNode("div", {
      class: vue.normalizeClass(["formkit-wrapper flex items-center", [props.value.wrapperClass ?? '']])
    }, [
      (slots.value.prefix)
        ? (vue.openBlock(), vue.createElementBlock("span", _hoisted_2$1, vue.toDisplayString(slots.value.prefix), 1 /* TEXT */))
        : vue.createCommentVNode("v-if", true),
      (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.$slots.prefix))),
      vue.withDirectives(vue.createElementVNode("input", vue.mergeProps({ type: "text" }, __props.context.attributes, {
        class: "formkit-input",
        "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => ((field).value = $event)),
        onKeyup: formataMoedaInput,
        onBlur: _cache[1] || (_cache[1] = (...args) => (__props.context.blur && __props.context.blur(...args))),
        autocomplete: "off",
        maxlength: "16"
      }), null, 16 /* FULL_PROPS */), [
        [vue.vModelText, field.value]
      ]),
      (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.$slots.suffix))),
      (slots.value.suffix)
        ? (vue.openBlock(), vue.createElementBlock("span", _hoisted_3, vue.toDisplayString(slots.value.suffix), 1 /* TEXT */))
        : vue.createCommentVNode("v-if", true)
    ], 2 /* CLASS */),
    (__props.context.help)
      ? (vue.openBlock(), vue.createElementBlock("span", {
          key: 1,
          class: vue.normalizeClass(["formkit-help", [props.value.helpClass ?? '']])
        }, [
          vue.createTextVNode(vue.toDisplayString(__props.context.help) + " ", 1 /* TEXT */),
          (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.$slots.help)))
        ], 2 /* CLASS */))
      : vue.createCommentVNode("v-if", true),
    (_ctx.hasMessages)
      ? (vue.openBlock(), vue.createElementBlock("ul", _hoisted_4, [
          (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(__props.context.messages, (msg) => {
            return (vue.openBlock(), vue.createElementBlock("li", {
              class: "formkit-message",
              key: msg.key
            }, vue.toDisplayString(msg.value), 1 /* TEXT */))
          }), 128 /* KEYED_FRAGMENT */))
        ]))
      : vue.createCommentVNode("v-if", true)
  ], 10 /* CLASS, PROPS */, _hoisted_1$1))
}
}

};

script$1.__file = "src/components/inputs/currency.vue";

const _hoisted_1 = { class: "border-b-2 border-zinc-300 py-1" };
const _hoisted_2 = ["onClick"];

var script = {
  __name: 'object',
  props: ['context'],
  setup(__props) {

const { context } = __props;
 
 
 
const props = vue.computed(() => context.node?.props || {}); 
const keys = vue.ref(Object.keys(context.value));
const model = vue.ref(Object.values(context.value));
const modelTypes = vue.ref([]);
const render = vue.ref(true);
const types = {
  'text':'Text',
  'number':'Number',
  'toggle':'Boolean', 
};

function forceRender(){
  render.value = false;
  vue.nextTick(() => {
    render.value = true;
  });
}

function addItem(){
  keys.value.push(' ');
  model.value.push(' ');
  forceRender();
  setValue();
}

function removeItem(k){
  keys.value.splice(k, 1);
  model.value.splice(k, 1); 
  forceRender();
  setValue();
}
 
async function setValue () { 
  vue.nextTick(() => {
    context.node.input( 
      _.zipObject(keys.value, model.value) 
    );  
  });
}  

return (_ctx, _cache) => {
  const _component_FormKit = vue.resolveComponent("FormKit");

  return (render.value)
    ? (vue.openBlock(), vue.createBlock(_component_FormKit, {
        key: 0,
        type: "group",
        outerClass: "formkit-object pt-2"
      }, {
        default: vue.withCtx(() => [
          vue.createElementVNode("p", _hoisted_1, vue.toDisplayString(props.value.label ?? __props.context.meta), 1 /* TEXT */),
          (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(keys.value, (idx, k) => {
            return (vue.openBlock(), vue.createElementBlock("div", {
              class: "flex gap-2 py-2 items-center pl-2",
              key: k
            }, [
              vue.createVNode(_component_FormKit, {
                modelValue: keys.value[k],
                "onUpdate:modelValue": $event => ((keys.value[k]) = $event),
                onInput: setValue
              }, null, 8 /* PROPS */, ["modelValue", "onUpdate:modelValue"]),
              vue.createTextVNode(": "),
              vue.createVNode(_component_FormKit, {
                modelValue: model.value[k],
                "onUpdate:modelValue": $event => ((model.value[k]) = $event),
                onInput: setValue,
                type: modelTypes.value[k] ?? 'text'
              }, null, 8 /* PROPS */, ["modelValue", "onUpdate:modelValue", "type"]),
              vue.createVNode(_component_FormKit, {
                type: "select",
                options: types,
                modelValue: modelTypes.value[k],
                "onUpdate:modelValue": $event => ((modelTypes.value[k]) = $event),
                onChange: forceRender
              }, null, 8 /* PROPS */, ["modelValue", "onUpdate:modelValue"]),
              vue.createElementVNode("button", {
                type: "button",
                onClick: e => removeItem(k)
              }, [
                vue.createVNode(vue.unref(script$s), { class: "h-5" })
              ], 8 /* PROPS */, _hoisted_2)
            ]))
          }), 128 /* KEYED_FRAGMENT */)),
          vue.createElementVNode("button", {
            type: "button",
            onClick: addItem,
            class: "block w-full py-2 bg-zinc-100 hover:bg-zinc-200"
          }, [
            vue.createVNode(vue.unref(script$r), { class: "h-4 m-auto" })
          ])
        ]),
        _: 1 /* STABLE */
      }))
    : vue.createCommentVNode("v-if", true)
}
}

};

script.__file = "src/components/inputs/object.vue";

let arrOptions = [];
const searchFeature = async (node) => {
  // const { $axios } = useNuxtApp()
  // const schemaModel = inject('model')
  const $axios = axios; 
  const Instance = ResourceClass({ $axios });   

  const getOptions = async ({ rootApi, fieldLabel, fieldValue, ...data }) => {
    try{   
      if( rootApi ){ 
        rootApi = interpolate(rootApi, { data: node.value });
        Instance.setModel({ api:{ ...data,  rootApi, resource:{} } });

        let { rows } = await Instance.getData({ data: node.value}); 

        arrOptions = rows && rows.map((i, k) => ({ 
            label: _.get(i, fieldLabel, i.toString()), 
            value: _.get(i, fieldValue, k)
          }) 
        );  
      }
    }catch(e){
        alert('Erro to get data from '+ rootApi);
        console.log('Erro select input', e);
    }
  };

  const init = async () => { 
    console.log('pre init', node.props);
    if( !node.props?.model ) return 'DISMISSED';
    node.props.options = node.props.options ?? [];

    let { model = {}, overwrite = {} } = node.props;
    model = mergeDeep(model, overwrite);
    if( model && typeof model  == 'string' ) 
      return console.error('model string not loaded')
    
    await getOptions(model.api);
  };
 
  node.on('created', async () => {
    await init();
    // Ensure our matches prop starts as an array.
    node.props.matches = [];
    node.props.selection = '';
    node.props.active = ''; 
    node.props.allOptions = [...arrOptions, ...node.props.options].map((i, k) => {
      if( typeof i == 'string' )
         i = { value:k, label:i };
      return i
    });  

    if( node.value ){
      let preSelected = node.props.allOptions.find(i => i.value == node.value);
      node.props.active = preSelected?.label ?? '??';
    }
    // When we actually have an value to set:
    const setValue = async (e) => {
      if (e && typeof e.preventDefault === 'function') e.preventDefault();
      let selected = node.props.selection;
      let modelFound = node.props.allOptions.find(
        i => {
          return i.label === selected
        }
      );
      
      node.input( modelFound?.value );
      node.props.active = modelFound?.label ?? selected;
      node.props.selection = '';
      node.props.searchValue = '';

      await new Promise((r) => setTimeout(r, 50)); // "next tick"

      if ( document.querySelector('input#' + node.props.id) ) {
        document.querySelector('input#' + node.props.id).focus();
      }
    };

    // Perform a soft selection, this is shown as a highlight in the dropdown
    const select = (delta) => { 
      const available = node.props.matches;
      let idx = available.indexOf(node.props.selection) + delta;
      if (idx >= available.length) {
        idx = 0;
      } else if (idx < 0) {
        idx = available.length - 1;
      }
      node.props.selection = available[idx];
    };

    // Add some new "handlers" for our autocomplete. The handlers object is
    // just a conventionally good place to put event handlers. Auto complete
    // inputs always have to deal with lots of keyboard events, so that logic
    // is registered here.
    Object.assign(node.context.handlers, {
      setValue,
      selection: (e) => {
        // This handler is called when entering data into the search input.
        switch (e.key) {
          case 'Enter':
            return setValue()
          case 'ArrowDown':
            e.preventDefault();
            return select(1)
          case 'ArrowUp':
            e.preventDefault();
            return select(-1)
        }
      },
      search(e) {
        node.props.searchValue = e.target.value;
      },
      hover: (e) => {
        node.props.selection = e.target.textContent;
      },
      unhover: (e) => {
        if (e.target.textContent === node.props.selection) {
          node.props.selection = '';
        }
      },
    });
 
  });

  // Perform filtering when the search value changes
  node.on('prop:searchValue', ({ payload: value }) => {
    const results = node.props.allOptions.filter((option) => { 
      return option.label.toLowerCase().startsWith(value.toLowerCase())
    });
    if (!results.length) results.push({ label:'No matches' });
    node.props.matches = results;
  });
};

const schema$3 = [ 
  {
    if: "$value && $active",
    then: [
      {
        $el: 'a',
        attrs: {
          id: '$id',
          href: '#',
          class: 'block border-2 border-black p-2',
          onClick: '$handlers.setValue',
          title: 'Click to change'
        },
        children: '$active',
      },
    ],
    else: [
      {
        $el: 'input',
        bind: '$attrs',
        attrs: {
          id: '$id',
          class: '$classes.input',
          onKeydown: '$handlers.selection',
          onInput: '$handlers.search',
          value: '$searchValue',
        },
      },
      {
        $el: 'ul',
        if: '$matches.length < $allOptions.length',
        attrs: {
          class: '$classes.dropdown',
        },
        children: [
          {
            $el: 'li',
            for: ['match', '$matches'],
            attrs: {
              'data-selected': {
                if: '$selection === $match.value',
                then: 'true',
                else: 'false',
              },
              class: 'formkit-dropdown-item border-b border-2 cursor-pointer p-1',
              onClick: '$handlers.setValue',
              onMouseenter: '$handlers.hover',
              onMouseleave: '$handlers.unhover',
            },
            children: '$match.label',
          },
        ],
      },
    ],
  }, 
];

const autocomplete = vue$1.createInput(schema$3, {
  props: ['options', 'allOptions', 'matches', 'selection', 'searchValue', 'active', 'overwrite', 'model'],
  features: [searchFeature],
});

const features$2 = (node) => {
  const $axios = axios;
  // const { $axios } = useNuxtApp()
  vue.inject('model');
  const Instance = ResourceClass({ $axios });
   
  // We wait for our node to be fully  "created" before we start to add our
  // handlers to ensure the core Vue plugin has added its context object:
  node.on('created', () => {  
    // Ensure our matches prop starts as an array.
    const upload = async (e) => { 
      console.debug('upload change');
      let file = e.target.files[0];
      let { model = {}, overwrite = {} } = node.props;
      
      const formData = new FormData();
      formData.append('file', file);

      // model = URL.createObjectURL(file);
      model = mergeDeep(model, overwrite);
      Instance.setModel(model);
 
      return await Instance.saveData( 
        formData
      )
      .then(({data}) => {
        if( data )
          node.input( _.get(data, _.get(model, 'api.wrapData', '[0].src'), JSON.stringify(data)) ); 
        else {
            alert('Upload error');
            console.error(data);
        }
      })
      .catch((err) => {
        alert(err.message || err);
        console.error(err); 
      })
    }; 

    const selectFile = (e) => {
      if (e && typeof e.preventDefault === 'function') e.preventDefault();
      
      console.debug('Select file clicked');
      var input = document.createElement('input');
      input.type = 'file';
      input.name = 'upload';
      input.onchange = e => upload(e);
      input.click();
    };
    // Add some new "handlers" for our autocomplete. The handlers object is
    // just a conventionally good place to put event handlers. Auto complete
    // inputs always have to deal with lots of keyboard events, so that logic
    // is registered here.
    Object.assign(node.context.handlers, {
      'selectFile': selectFile, 
      hover: (e) => {
        node.props.selection = e.target.textContent;
      },
      unhover: (e) => {
        if (e.target.textContent === node.props.selection) {
          node.props.selection = '';
        }
      },
    });
 
  });

};

const schema$2 = [ 
  {
    $el: 'div',
    attrs: {  
      class: 'flex justify-between items-center gap-2 border-y border-1 w-full',  
    },
    children: [ 
      {
        if: '$value',
        then: [
          {
            if: '$baseUrl',
            then:[
              {
                $el: 'img',
                attrs: {
                  id: '$id',
                  src: '$baseUrl + $value',
                  class: 'w-12',
                },
                children: ''
              }
            ],
            else:{
                $el: 'img',
                attrs: {
                  id: '$id',
                  src: '$value',
                  class: 'w-14',
                },
                children: '',
            } 
          }
        ],
      }, 
      {   
        $el: 'input',
        attrs: {
          name: 'imageUrl',
          onInput: '$handlers.DOMInput',
          onBlur: '$handlers.blur',
          value: '$_value',
          class: 'formkit-input'
        },
      }, 
      {
        if: '$model.api.rootApi',
        then: [
          {
            $el: 'a',
            attrs: {
              id: 'upload',
              href: '#',
              class: 'p-2',
              onClick: '$handlers.selectFile',
              title: 'Upload new'
            },
            children: [
              {
                $el:'svg',
                attrs:{
                  xmlns:"http://www.w3.org/2000/svg",
                  viewBox:"0 0 512 512",
                  class: 'w-4'
                },
                children:[
                  {
                    $el: 'path',
                    attrs:{
                      d:"M288 109.3V352c0 17.7-14.3 32-32 32s-32-14.3-32-32V109.3l-73.4 73.4c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3l128-128c12.5-12.5 32.8-12.5 45.3 0l128 128c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L288 109.3zM64 352H192c0 35.3 28.7 64 64 64s64-28.7 64-64H448c35.3 0 64 28.7 64 64v32c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V416c0-35.3 28.7-64 64-64zM432 456c13.3 0 24-10.7 24-24s-10.7-24-24-24s-24 10.7-24 24s10.7 24 24 24z"
                    }
                  }
                ]
              }
            ]
          }, 
        ]
      }
    ]
  }
];
 
const image = vue$1.createInput(schema$2, {
  props: ['overwrite', 'model', 'baseUrl'],
  features: [features$2],
});

const features$1 = (node) => {
  let loading = false; 
  const $axios = axios; 
  // const schemaModel = inject('model')
  const Instance = ResourceClass({ $axios }); 
  node.props.arrOptions = [];

  const getOptions = async ({ rootApi, fieldLabel, fieldValue, ...data }) => {
    try{  
      console.log('getOptions', { rootApi, fieldLabel, fieldValue, ...data });
      if( rootApi ){
        loading = true;
        rootApi = interpolate(rootApi, { data: node.value });
        Instance.setModel({ api:{ ...data,  rootApi, resource:{} } });

        let { rows } = await Instance.getData({ data: node.value}); 

        node.props.arrOptions = rows && rows.map((i, k) => ({ 
            label: _.get(i, fieldLabel, i.toString()), 
            value: _.get(i, fieldValue, k)
          }) 
        ); 

        loading = false; 
      }
    }catch(e){
        alert('Erro to get data from '+ rootApi);
        console.log('Erro select input', e);
    }
  };

  const init = async () => { 
    let { model = {}, overwrite = {} } = node.props.attrs;
    model = mergeDeep(model, overwrite);
    if( model && typeof model  == 'string' ) return console.error('model string not loaded')
    
    getOptions(model.api);
  };
  
  init(); 
  // We wait for our node to be fully  "created" before we start to add our
  // handlers to ensure the core Vue plugin has added its context object:
  node.on('created', () => {  
    node.props.arrOptions = node.props.options;

    Object.assign(node.context.handlers, { 
      setValue: e => {
        node.input(e); 
      }, 
      refresh: () => { 
        let { model = {}, overwrite = {} } = node.props;
        model = mergeDeep(model, overwrite);
        if( model && typeof model  == 'string' ) return console.error('model string not loaded')
        
        getOptions(model.api);
      },  
    });
 
  });
};
 
const schema$1 = [  
  { 
    $el: 'div',
    attrs: {    
      class: 'formkit-inner flex border-2 border-black',
    },
    children:[
      {   
        $el: 'select',
        attrs: { 
          name: '$context.name',
          id: '$context.id',
          oninput: '$handlers.DOMInput', 
          value: '$_value',
          class: 'formkit-input border-0',
        },
        children:[
          {
            $el: 'option',
            for: ['item', '$arrOptions'],
            attrs:{
              value: '$item.value'
            },
            children: '$item.label'
          }
        ]
      }, 
      {
        $el: 'button', 
        attrs:{
          type: 'button',
          onClick: '$handlers.refresh',
          title: "Refresh list"
        },
        children: [
          {
            $el:'svg',
            attrs:{
              xmlns:"http://www.w3.org/2000/svg",
              viewBox:"0 0 512 512",
              class: 'w-4 m-2'
            },
            children:[
              {
                $el: 'path',
                attrs:{
                  d:"M105.1 202.6c7.7-21.8 20.2-42.3 37.8-59.8c62.5-62.5 163.8-62.5 226.3 0L386.3 160H336c-17.7 0-32 14.3-32 32s14.3 32 32 32H463.5c0 0 0 0 0 0h.4c17.7 0 32-14.3 32-32V64c0-17.7-14.3-32-32-32s-32 14.3-32 32v51.2L414.4 97.6c-87.5-87.5-229.3-87.5-316.8 0C73.2 122 55.6 150.7 44.8 181.4c-5.9 16.7 2.9 34.9 19.5 40.8s34.9-2.9 40.8-19.5zM39 289.3c-5 1.5-9.8 4.2-13.7 8.2c-4 4-6.7 8.8-8.1 14c-.3 1.2-.6 2.5-.8 3.8c-.3 1.7-.4 3.4-.4 5.1V448c0 17.7 14.3 32 32 32s32-14.3 32-32V396.9l17.6 17.5 0 0c87.5 87.4 229.3 87.4 316.7 0c24.4-24.4 42.1-53.1 52.9-83.7c5.9-16.7-2.9-34.9-19.5-40.8s-34.9 2.9-40.8 19.5c-7.7 21.8-20.2 42.3-37.8 59.8c-62.5 62.5-163.8 62.5-226.3 0l-.1-.1L125.6 352H176c17.7 0 32-14.3 32-32s-14.3-32-32-32H48.4c-1.6 0-3.2 .1-4.8 .3s-3.1 .5-4.6 1z"
                }
              }
            ]
          }
        ] 
      }
    ]
  } 
]; 

const dynamic = vue$1.createInput(schema$1, {
  props: ['overwrite', 'model', 'options', 'arrOptions'],
  features: [features$1],
});

const features = (node) => {
  let loading = false; 
  const $axios = axios;
  // const { $axios } = useNuxtApp()
  // const schemaModel = inject('model')
  const Instance = ResourceClass({ $axios }); 
  node.props.arrOptions = [];
  node.props.arrFiltered = [];

  if(!Array.isArray(node.value))
    node.input([]);

  const getOptions = async ({ rootApi, fieldLabel, fieldValue, ...data }) => {
    try{  
      console.debug('getOptions', { rootApi, fieldLabel, fieldValue, ...data });
      if( rootApi ){
        loading = true;
        rootApi = interpolate(rootApi, { data: node.value });
        Instance.setModel({ api:{ ...data,  rootApi, resource:{} } });

        let { rows } = await Instance.getData({ data: node.value }); 

        node.props.arrOptions = rows && rows.map((i, k) => ({ 
            label: _.get(i, fieldLabel, i.toString()), 
            value: _.get(i, fieldValue, k)
          }) 
        ); 

        node.props.arrFiltered = node.props.arrOptions;
        loading = false; 
      }
    }catch(e){
        alert('Erro to get data from '+ rootApi);
        console.log('Erro select input', e);
    }
  };

  const init = async () => { 
    let { model = {}, overwrite = {} } = node.props.attrs;
    model = mergeDeep(model, overwrite);
    if( model && typeof model  == 'string' ) return console.error('model string not loaded')
    
    getOptions(model.api);
  };
  
  init(); 
  // We wait for our node to be fully  "created" before we start to add our
  // handlers to ensure the core Vue plugin has added its context object:
  node.on('created', () => {  
    node.props.arrOptions = node.props.options ?? [];

    Object.assign(node.context.handlers, { 
      setValue: e => {
        node.input(e); 
      }, 
      checked: e => {
        let item = e?.target?.value;
        let exists = node.value.findIndex(i => i == item);
        if( exists >= 0 ){
          node.input( node.value.splice(exists, 1) ); 
        }else {
          node.input([...node.value, item]);
        } 
      },
      isChecked: e => {  
        return node.value.some(i => e == i)
      },
      filter: e => {
        let busca = e.target?.value;
        if( busca )
          node.props.arrFiltered = node.props.arrOptions.filter(
            i => i.label?.toLowerCase().startsWith(busca?.toLowerCase())
          );
        else
          node.props.arrFiltered = node.props.arrOptions;
      },
      refresh: () => { 
        let { model = {}, overwrite = {} } = node.props;
        model = mergeDeep(model, overwrite);
        if( model && typeof model  == 'string' ) return console.error('model string not loaded')
        
        getOptions(model.api);
      },  
    });
 
  });
};
 
const schema = [  
  {
    $el: 'div',
    attrs: {
      class: 'w-full'
    },
    children:[
      {   
        $el: 'input',
        attrs: { 
          type: 'search',
          name: '$context.name',
          id: '$context.id',
          oninput: '$handlers.filter',  
          class: 'formkit-input w-full',
          placeholder: 'filter'
        }, 
      },
      {
        $el: 'div', 
        attrs: {
          class: 'grid grid-cols-3 py-2 gap-2 w-full max-h-28 overflow-y-auto overflow-x-hidden'
        },
        children:[
          {
            $el: 'label',
            for: ['item', '$arrFiltered'],
            attrs:{
              for: '#$item.value', 
              value: '$item.value',
              class: 'flex items-center gap-2 p-2',
            },
            children: [ 
              {
                $el: 'input', 
                attrs: {
                  type: 'checkbox',
                  class: 'flex flex-col',
                  value: '$item.value',
                  onclick: '$handlers.checked',
                  checked: '$handlers.isChecked($item.value)'
                },
              },
              {
                $el: 'p',  
                attrs: {
                  class: 'whitespace-nowrap', 
                },
                children: '$item.label'
              }
            ]
          }
        ]
      } 
    ]
  }
]; 

const multiple = vue$1.createInput(schema, {
  props: ['overwrite', 'model', 'options', 'arrOptions', 'arrFiltered'],
  features: [features],
});

// Custom inputs
// import CodeInput from './code.vue'
// import JsonInput from './json.vue'
// import EditorInput from './editor.vue'

var inputs = {
  // CodeInput, 
  // EditorInput,
  ToggleInput: script$4,
  TagsInput: script$3,
  RepeaterInput: script$2,
  // DateRangeInput: DateRange,
  CurrencyInput: script$1,
  GridInput: script$6,
  FormInput: script$5,
  ObjectInput: script,
  AutocompleteInput: autocomplete,
  ImageInput: image,
  DynamicInput: dynamic,
  MultipleInput: multiple, 
};

// (function (global, factory) {
//   typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
//   typeof define === 'function' && define.amd ? define(['exports'], factory) :
//   (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.IMask = {}));
// })(this, (function (exports) { 'use strict';

  /** Checks if value is string */
  function isString(str) {
    return typeof str === 'string' || str instanceof String;
  }

  /** Checks if value is object */
  function isObject(obj) {
    return typeof obj === 'object' && obj != null && obj?.constructor?.name === 'Object';
  }
  function pick(obj, keys) {
    if (Array.isArray(keys)) return pick(obj, (_, k) => keys.includes(k));
    return Object.entries(obj).reduce((acc, _ref) => {
      let [k, v] = _ref;
      if (keys(v, k)) acc[k] = v;
      return acc;
    }, {});
  }

  /** Direction */
  const DIRECTION = {
    NONE: 'NONE',
    LEFT: 'LEFT',
    FORCE_LEFT: 'FORCE_LEFT',
    RIGHT: 'RIGHT',
    FORCE_RIGHT: 'FORCE_RIGHT'
  };

  /** Direction */

  function forceDirection(direction) {
    switch (direction) {
      case DIRECTION.LEFT:
        return DIRECTION.FORCE_LEFT;
      case DIRECTION.RIGHT:
        return DIRECTION.FORCE_RIGHT;
      default:
        return direction;
    }
  }

  /** Escapes regular expression control chars */
  function escapeRegExp(str) {
    return str.replace(/([.*+?^=!:${}()|[\]/\\])/g, '\\$1');
  }

  // cloned from https://github.com/epoberezkin/fast-deep-equal with small changes
  function objectIncludes(b, a) {
    if (a === b) return true;
    const arrA = Array.isArray(a),
      arrB = Array.isArray(b);
    let i;
    if (arrA && arrB) {
      if (a.length != b.length) return false;
      for (i = 0; i < a.length; i++) if (!objectIncludes(a[i], b[i])) return false;
      return true;
    }
    if (arrA != arrB) return false;
    if (a && b && typeof a === 'object' && typeof b === 'object') {
      const dateA = a instanceof Date,
        dateB = b instanceof Date;
      if (dateA && dateB) return a.getTime() == b.getTime();
      if (dateA != dateB) return false;
      const regexpA = a instanceof RegExp,
        regexpB = b instanceof RegExp;
      if (regexpA && regexpB) return a.toString() == b.toString();
      if (regexpA != regexpB) return false;
      const keys = Object.keys(a);
      // if (keys.length !== Object.keys(b).length) return false;

      for (i = 0; i < keys.length; i++) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
      for (i = 0; i < keys.length; i++) if (!objectIncludes(b[keys[i]], a[keys[i]])) return false;
      return true;
    } else if (a && b && typeof a === 'function' && typeof b === 'function') {
      return a.toString() === b.toString();
    }
    return false;
  }

  /** Selection range */

  /** Provides details of changing input */
  class ActionDetails {
    /** Current input value */

    /** Current cursor position */

    /** Old input value */

    /** Old selection */

    constructor(opts) {
      Object.assign(this, opts);

      // double check if left part was changed (autofilling, other non-standard input triggers)
      while (this.value.slice(0, this.startChangePos) !== this.oldValue.slice(0, this.startChangePos)) {
        --this.oldSelection.start;
      }

      // double check right part
      while (this.value.slice(this.cursorPos) !== this.oldValue.slice(this.oldSelection.end)) {
        if (this.value.length - this.cursorPos < this.oldValue.length - this.oldSelection.end) ++this.oldSelection.end;else ++this.cursorPos;
      }
    }

    /** Start changing position */
    get startChangePos() {
      return Math.min(this.cursorPos, this.oldSelection.start);
    }

    /** Inserted symbols count */
    get insertedCount() {
      return this.cursorPos - this.startChangePos;
    }

    /** Inserted symbols */
    get inserted() {
      return this.value.substr(this.startChangePos, this.insertedCount);
    }

    /** Removed symbols count */
    get removedCount() {
      // Math.max for opposite operation
      return Math.max(this.oldSelection.end - this.startChangePos ||
      // for Delete
      this.oldValue.length - this.value.length, 0);
    }

    /** Removed symbols */
    get removed() {
      return this.oldValue.substr(this.startChangePos, this.removedCount);
    }

    /** Unchanged head symbols */
    get head() {
      return this.value.substring(0, this.startChangePos);
    }

    /** Unchanged tail symbols */
    get tail() {
      return this.value.substring(this.startChangePos + this.insertedCount);
    }

    /** Remove direction */
    get removeDirection() {
      if (!this.removedCount || this.insertedCount) return DIRECTION.NONE;

      // align right if delete at right
      return (this.oldSelection.end === this.cursorPos || this.oldSelection.start === this.cursorPos) &&
      // if not range removed (event with backspace)
      this.oldSelection.end === this.oldSelection.start ? DIRECTION.RIGHT : DIRECTION.LEFT;
    }
  }

  /** Applies mask on element */
  function IMask(el, opts) {
    // currently available only for input-like elements
    return new IMask.InputMask(el, opts);
  }

  // TODO can't use overloads here because of https://github.com/microsoft/TypeScript/issues/50754
  // export function maskedClass(mask: string): typeof MaskedPattern;
  // export function maskedClass(mask: DateConstructor): typeof MaskedDate;
  // export function maskedClass(mask: NumberConstructor): typeof MaskedNumber;
  // export function maskedClass(mask: Array<any> | ArrayConstructor): typeof MaskedDynamic;
  // export function maskedClass(mask: MaskedDate): typeof MaskedDate;
  // export function maskedClass(mask: MaskedNumber): typeof MaskedNumber;
  // export function maskedClass(mask: MaskedEnum): typeof MaskedEnum;
  // export function maskedClass(mask: MaskedRange): typeof MaskedRange;
  // export function maskedClass(mask: MaskedRegExp): typeof MaskedRegExp;
  // export function maskedClass(mask: MaskedFunction): typeof MaskedFunction;
  // export function maskedClass(mask: MaskedPattern): typeof MaskedPattern;
  // export function maskedClass(mask: MaskedDynamic): typeof MaskedDynamic;
  // export function maskedClass(mask: Masked): typeof Masked;
  // export function maskedClass(mask: typeof Masked): typeof Masked;
  // export function maskedClass(mask: typeof MaskedDate): typeof MaskedDate;
  // export function maskedClass(mask: typeof MaskedNumber): typeof MaskedNumber;
  // export function maskedClass(mask: typeof MaskedEnum): typeof MaskedEnum;
  // export function maskedClass(mask: typeof MaskedRange): typeof MaskedRange;
  // export function maskedClass(mask: typeof MaskedRegExp): typeof MaskedRegExp;
  // export function maskedClass(mask: typeof MaskedFunction): typeof MaskedFunction;
  // export function maskedClass(mask: typeof MaskedPattern): typeof MaskedPattern;
  // export function maskedClass(mask: typeof MaskedDynamic): typeof MaskedDynamic;
  // export function maskedClass<Mask extends typeof Masked> (mask: Mask): Mask;
  // export function maskedClass(mask: RegExp): typeof MaskedRegExp;
  // export function maskedClass(mask: (value: string, ...args: any[]) => boolean): typeof MaskedFunction;

  /** Get Masked class by mask type */
  function maskedClass(mask) /* TODO */{
    if (mask == null) throw new Error('mask property should be defined');
    if (mask instanceof RegExp) return IMask.MaskedRegExp;
    if (isString(mask)) return IMask.MaskedPattern;
    if (mask === Date) return IMask.MaskedDate;
    if (mask === Number) return IMask.MaskedNumber;
    if (Array.isArray(mask) || mask === Array) return IMask.MaskedDynamic;
    if (IMask.Masked && mask.prototype instanceof IMask.Masked) return mask;
    if (IMask.Masked && mask instanceof IMask.Masked) return mask.constructor;
    if (mask instanceof Function) return IMask.MaskedFunction;
    console.warn('Mask not found for mask', mask); // eslint-disable-line no-console
    return IMask.Masked;
  }
  function normalizeOpts(opts) {
    if (!opts) throw new Error('Options in not defined');
    if (IMask.Masked) {
      if (opts.prototype instanceof IMask.Masked) return {
        mask: opts
      };

      /*
        handle cases like:
        1) opts = Masked
        2) opts = { mask: Masked, ...instanceOpts }
      */
      const {
        mask = undefined,
        ...instanceOpts
      } = opts instanceof IMask.Masked ? {
        mask: opts
      } : isObject(opts) && opts.mask instanceof IMask.Masked ? opts : {};
      if (mask) {
        const _mask = mask.mask;
        return {
          ...pick(mask, (_, k) => !k.startsWith('_')),
          mask: mask.constructor,
          _mask,
          ...instanceOpts
        };
      }
    }
    if (!isObject(opts)) return {
      mask: opts
    };
    return {
      ...opts
    };
  }

  // TODO can't use overloads here because of https://github.com/microsoft/TypeScript/issues/50754

  // From masked
  // export default function createMask<Opts extends Masked, ReturnMasked=Opts> (opts: Opts): ReturnMasked;
  // // From masked class
  // export default function createMask<Opts extends MaskedOptions<typeof Masked>, ReturnMasked extends Masked=InstanceType<Opts['mask']>> (opts: Opts): ReturnMasked;
  // export default function createMask<Opts extends MaskedOptions<typeof MaskedDate>, ReturnMasked extends MaskedDate=MaskedDate<Opts['parent']>> (opts: Opts): ReturnMasked;
  // export default function createMask<Opts extends MaskedOptions<typeof MaskedNumber>, ReturnMasked extends MaskedNumber=MaskedNumber<Opts['parent']>> (opts: Opts): ReturnMasked;
  // export default function createMask<Opts extends MaskedOptions<typeof MaskedEnum>, ReturnMasked extends MaskedEnum=MaskedEnum<Opts['parent']>> (opts: Opts): ReturnMasked;
  // export default function createMask<Opts extends MaskedOptions<typeof MaskedRange>, ReturnMasked extends MaskedRange=MaskedRange<Opts['parent']>> (opts: Opts): ReturnMasked;
  // export default function createMask<Opts extends MaskedOptions<typeof MaskedRegExp>, ReturnMasked extends MaskedRegExp=MaskedRegExp<Opts['parent']>> (opts: Opts): ReturnMasked;
  // export default function createMask<Opts extends MaskedOptions<typeof MaskedFunction>, ReturnMasked extends MaskedFunction=MaskedFunction<Opts['parent']>> (opts: Opts): ReturnMasked;
  // export default function createMask<Opts extends MaskedOptions<typeof MaskedPattern>, ReturnMasked extends MaskedPattern=MaskedPattern<Opts['parent']>> (opts: Opts): ReturnMasked;
  // export default function createMask<Opts extends MaskedOptions<typeof MaskedDynamic>, ReturnMasked extends MaskedDynamic=MaskedDynamic<Opts['parent']>> (opts: Opts): ReturnMasked;
  // // From mask opts
  // export default function createMask<Opts extends MaskedOptions<Masked>, ReturnMasked=Opts extends MaskedOptions<infer M> ? M : never> (opts: Opts): ReturnMasked;
  // export default function createMask<Opts extends MaskedNumberOptions, ReturnMasked extends MaskedNumber=MaskedNumber<Opts['parent']>> (opts: Opts): ReturnMasked;
  // export default function createMask<Opts extends MaskedDateFactoryOptions, ReturnMasked extends MaskedDate=MaskedDate<Opts['parent']>> (opts: Opts): ReturnMasked;
  // export default function createMask<Opts extends MaskedEnumOptions, ReturnMasked extends MaskedEnum=MaskedEnum<Opts['parent']>> (opts: Opts): ReturnMasked;
  // export default function createMask<Opts extends MaskedRangeOptions, ReturnMasked extends MaskedRange=MaskedRange<Opts['parent']>> (opts: Opts): ReturnMasked;
  // export default function createMask<Opts extends MaskedPatternOptions, ReturnMasked extends MaskedPattern=MaskedPattern<Opts['parent']>> (opts: Opts): ReturnMasked;
  // export default function createMask<Opts extends MaskedDynamicOptions, ReturnMasked extends MaskedDynamic=MaskedDynamic<Opts['parent']>> (opts: Opts): ReturnMasked;
  // export default function createMask<Opts extends MaskedOptions<RegExp>, ReturnMasked extends MaskedRegExp=MaskedRegExp<Opts['parent']>> (opts: Opts): ReturnMasked;
  // export default function createMask<Opts extends MaskedOptions<Function>, ReturnMasked extends MaskedFunction=MaskedFunction<Opts['parent']>> (opts: Opts): ReturnMasked;

  /** Creates new {@link Masked} depending on mask type */
  function createMask(opts) {
    if (IMask.Masked && opts instanceof IMask.Masked) return opts;
    const nOpts = normalizeOpts(opts);
    const MaskedClass = maskedClass(nOpts.mask);
    if (!MaskedClass) throw new Error(`Masked class is not found for provided mask ${nOpts.mask}, appropriate module needs to be imported manually before creating mask.`);
    if (nOpts.mask === MaskedClass) delete nOpts.mask;
    if (nOpts._mask) {
      nOpts.mask = nOpts._mask;
      delete nOpts._mask;
    }
    return new MaskedClass(nOpts);
  }
  IMask.createMask = createMask;

  /**  Generic element API to use with mask */
  class MaskElement {
    /** */

    /** */

    /** */

    /** Safely returns selection start */
    get selectionStart() {
      let start;
      try {
        start = this._unsafeSelectionStart;
      } catch {}
      return start != null ? start : this.value.length;
    }

    /** Safely returns selection end */
    get selectionEnd() {
      let end;
      try {
        end = this._unsafeSelectionEnd;
      } catch {}
      return end != null ? end : this.value.length;
    }

    /** Safely sets element selection */
    select(start, end) {
      if (start == null || end == null || start === this.selectionStart && end === this.selectionEnd) return;
      try {
        this._unsafeSelect(start, end);
      } catch {}
    }

    /** */
    get isActive() {
      return false;
    }
    /** */

    /** */

    /** */
  }
  IMask.MaskElement = MaskElement;

  /** Bridge between HTMLElement and {@link Masked} */
  class HTMLMaskElement extends MaskElement {
    /** Mapping between HTMLElement events and mask internal events */
    static EVENTS_MAP = {
      selectionChange: 'keydown',
      input: 'input',
      drop: 'drop',
      click: 'click',
      focus: 'focus',
      commit: 'blur'
    };
    /** HTMLElement to use mask on */

    constructor(input) {
      super();
      this.input = input;
      this._handlers = {};
    }
    get rootElement() {
      return this.input.getRootNode?.() ?? document;
    }

    /**
      Is element in focus
    */
    get isActive() {
      return this.input === this.rootElement.activeElement;
    }

    /**
      Binds HTMLElement events to mask internal events
    */
    bindEvents(handlers) {
      Object.keys(handlers).forEach(event => this._toggleEventHandler(HTMLMaskElement.EVENTS_MAP[event], handlers[event]));
    }

    /**
      Unbinds HTMLElement events to mask internal events
    */
    unbindEvents() {
      Object.keys(this._handlers).forEach(event => this._toggleEventHandler(event));
    }
    _toggleEventHandler(event, handler) {
      if (this._handlers[event]) {
        this.input.removeEventListener(event, this._handlers[event]);
        delete this._handlers[event];
      }
      if (handler) {
        this.input.addEventListener(event, handler);
        this._handlers[event] = handler;
      }
    }
  }
  IMask.HTMLMaskElement = HTMLMaskElement;

  /** Bridge between InputElement and {@link Masked} */
  class HTMLInputMaskElement extends HTMLMaskElement {
    /** InputElement to use mask on */

    constructor(input) {
      super(input);
      this.input = input;
      this._handlers = {};
    }

    /** Returns InputElement selection start */
    get _unsafeSelectionStart() {
      return this.input.selectionStart != null ? this.input.selectionStart : this.value.length;
    }

    /** Returns InputElement selection end */
    get _unsafeSelectionEnd() {
      return this.input.selectionEnd;
    }

    /** Sets InputElement selection */
    _unsafeSelect(start, end) {
      this.input.setSelectionRange(start, end);
    }
    get value() {
      return this.input.value;
    }
    set value(value) {
      this.input.value = value;
    }
  }
  IMask.HTMLMaskElement = HTMLMaskElement;

  class HTMLContenteditableMaskElement extends HTMLMaskElement {
    /** Returns HTMLElement selection start */
    get _unsafeSelectionStart() {
      const root = this.rootElement;
      const selection = root.getSelection && root.getSelection();
      const anchorOffset = selection && selection.anchorOffset;
      const focusOffset = selection && selection.focusOffset;
      if (focusOffset == null || anchorOffset == null || anchorOffset < focusOffset) {
        return anchorOffset;
      }
      return focusOffset;
    }

    /** Returns HTMLElement selection end */
    get _unsafeSelectionEnd() {
      const root = this.rootElement;
      const selection = root.getSelection && root.getSelection();
      const anchorOffset = selection && selection.anchorOffset;
      const focusOffset = selection && selection.focusOffset;
      if (focusOffset == null || anchorOffset == null || anchorOffset > focusOffset) {
        return anchorOffset;
      }
      return focusOffset;
    }

    /** Sets HTMLElement selection */
    _unsafeSelect(start, end) {
      if (!this.rootElement.createRange) return;
      const range = this.rootElement.createRange();
      range.setStart(this.input.firstChild || this.input, start);
      range.setEnd(this.input.lastChild || this.input, end);
      const root = this.rootElement;
      const selection = root.getSelection && root.getSelection();
      if (selection) {
        selection.removeAllRanges();
        selection.addRange(range);
      }
    }

    /** HTMLElement value */
    get value() {
      return this.input.textContent || '';
    }
    set value(value) {
      this.input.textContent = value;
    }
  }
  IMask.HTMLContenteditableMaskElement = HTMLContenteditableMaskElement;

  /** Listens to element events and controls changes between element and {@link Masked} */
  class InputMask {
    /**
      View element
    */

    /** Internal {@link Masked} model */

    constructor(el, opts) {
      this.el = el instanceof MaskElement ? el : el.isContentEditable && el.tagName !== 'INPUT' && el.tagName !== 'TEXTAREA' ? new HTMLContenteditableMaskElement(el) : new HTMLInputMaskElement(el);
      this.masked = createMask(opts);
      this._listeners = {};
      this._value = '';
      this._unmaskedValue = '';
      this._saveSelection = this._saveSelection.bind(this);
      this._onInput = this._onInput.bind(this);
      this._onChange = this._onChange.bind(this);
      this._onDrop = this._onDrop.bind(this);
      this._onFocus = this._onFocus.bind(this);
      this._onClick = this._onClick.bind(this);
      this.alignCursor = this.alignCursor.bind(this);
      this.alignCursorFriendly = this.alignCursorFriendly.bind(this);
      this._bindEvents();

      // refresh
      this.updateValue();
      this._onChange();
    }
    maskEquals(mask) {
      return mask == null || this.masked?.maskEquals(mask);
    }

    /** Masked */
    get mask() {
      return this.masked.mask;
    }
    set mask(mask) {
      if (this.maskEquals(mask)) return;
      if (!(mask instanceof IMask.Masked) && this.masked.constructor === maskedClass(mask)) {
        // TODO "any" no idea
        this.masked.updateOptions({
          mask
        });
        return;
      }
      const masked = mask instanceof IMask.Masked ? mask : createMask({
        mask
      });
      masked.unmaskedValue = this.masked.unmaskedValue;
      this.masked = masked;
    }

    /** Raw value */
    get value() {
      return this._value;
    }
    set value(str) {
      if (this.value === str) return;
      this.masked.value = str;
      this.updateControl();
      this.alignCursor();
    }

    /** Unmasked value */
    get unmaskedValue() {
      return this._unmaskedValue;
    }
    set unmaskedValue(str) {
      if (this.unmaskedValue === str) return;
      this.masked.unmaskedValue = str;
      this.updateControl();
      this.alignCursor();
    }

    /** Typed unmasked value */
    get typedValue() {
      return this.masked.typedValue;
    }
    set typedValue(val) {
      if (this.masked.typedValueEquals(val)) return;
      this.masked.typedValue = val;
      this.updateControl();
      this.alignCursor();
    }

    /** Display value */
    get displayValue() {
      return this.masked.displayValue;
    }

    /** Starts listening to element events */
    _bindEvents() {
      this.el.bindEvents({
        selectionChange: this._saveSelection,
        input: this._onInput,
        drop: this._onDrop,
        click: this._onClick,
        focus: this._onFocus,
        commit: this._onChange
      });
    }

    /** Stops listening to element events */
    _unbindEvents() {
      if (this.el) this.el.unbindEvents();
    }

    /** Fires custom event */
    _fireEvent(ev, e) {
      const listeners = this._listeners[ev];
      if (!listeners) return;
      listeners.forEach(l => l(e));
    }

    /** Current selection start */
    get selectionStart() {
      return this._cursorChanging ? this._changingCursorPos : this.el.selectionStart;
    }

    /** Current cursor position */
    get cursorPos() {
      return this._cursorChanging ? this._changingCursorPos : this.el.selectionEnd;
    }
    set cursorPos(pos) {
      if (!this.el || !this.el.isActive) return;
      this.el.select(pos, pos);
      this._saveSelection();
    }

    /** Stores current selection */
    _saveSelection( /* ev */
    ) {
      if (this.displayValue !== this.el.value) {
        console.warn('Element value was changed outside of mask. Syncronize mask using `mask.updateValue()` to work properly.'); // eslint-disable-line no-console
      }
      this._selection = {
        start: this.selectionStart,
        end: this.cursorPos
      };
    }

    /** Syncronizes model value from view */
    updateValue() {
      this.masked.value = this.el.value;
      this._value = this.masked.value;
    }

    /** Syncronizes view from model value, fires change events */
    updateControl() {
      const newUnmaskedValue = this.masked.unmaskedValue;
      const newValue = this.masked.value;
      const newDisplayValue = this.displayValue;
      const isChanged = this.unmaskedValue !== newUnmaskedValue || this.value !== newValue;
      this._unmaskedValue = newUnmaskedValue;
      this._value = newValue;
      if (this.el.value !== newDisplayValue) this.el.value = newDisplayValue;
      if (isChanged) this._fireChangeEvents();
    }

    /** Updates options with deep equal check, recreates {@link Masked} model if mask type changes */
    updateOptions(opts) {
      const {
        mask,
        ...restOpts
      } = opts;
      const updateMask = !this.maskEquals(mask);
      const updateOpts = this.masked.optionsIsChanged(restOpts);
      if (updateMask) this.mask = mask;
      if (updateOpts) this.masked.updateOptions(restOpts); // TODO

      if (updateMask || updateOpts) this.updateControl();
    }

    /** Updates cursor */
    updateCursor(cursorPos) {
      if (cursorPos == null) return;
      this.cursorPos = cursorPos;

      // also queue change cursor for mobile browsers
      this._delayUpdateCursor(cursorPos);
    }

    /** Delays cursor update to support mobile browsers */
    _delayUpdateCursor(cursorPos) {
      this._abortUpdateCursor();
      this._changingCursorPos = cursorPos;
      this._cursorChanging = setTimeout(() => {
        if (!this.el) return; // if was destroyed
        this.cursorPos = this._changingCursorPos;
        this._abortUpdateCursor();
      }, 10);
    }

    /** Fires custom events */
    _fireChangeEvents() {
      this._fireEvent('accept', this._inputEvent);
      if (this.masked.isComplete) this._fireEvent('complete', this._inputEvent);
    }

    /** Aborts delayed cursor update */
    _abortUpdateCursor() {
      if (this._cursorChanging) {
        clearTimeout(this._cursorChanging);
        delete this._cursorChanging;
      }
    }

    /** Aligns cursor to nearest available position */
    alignCursor() {
      this.cursorPos = this.masked.nearestInputPos(this.masked.nearestInputPos(this.cursorPos, DIRECTION.LEFT));
    }

    /** Aligns cursor only if selection is empty */
    alignCursorFriendly() {
      if (this.selectionStart !== this.cursorPos) return; // skip if range is selected
      this.alignCursor();
    }

    /** Adds listener on custom event */
    on(ev, handler) {
      if (!this._listeners[ev]) this._listeners[ev] = [];
      this._listeners[ev].push(handler);
      return this;
    }

    /** Removes custom event listener */
    off(ev, handler) {
      if (!this._listeners[ev]) return this;
      if (!handler) {
        delete this._listeners[ev];
        return this;
      }
      const hIndex = this._listeners[ev].indexOf(handler);
      if (hIndex >= 0) this._listeners[ev].splice(hIndex, 1);
      return this;
    }

    /** Handles view input event */
    _onInput(e) {
      this._inputEvent = e;
      this._abortUpdateCursor();
      const details = new ActionDetails({
        // new state
        value: this.el.value,
        cursorPos: this.cursorPos,
        // old state
        oldValue: this.displayValue,
        oldSelection: this._selection
      });
      const oldRawValue = this.masked.rawInputValue;
      const offset = this.masked.splice(details.startChangePos, details.removed.length, details.inserted, details.removeDirection, {
        input: true,
        raw: true
      }).offset;

      // force align in remove direction only if no input chars were removed
      // otherwise we still need to align with NONE (to get out from fixed symbols for instance)
      const removeDirection = oldRawValue === this.masked.rawInputValue ? details.removeDirection : DIRECTION.NONE;
      let cursorPos = this.masked.nearestInputPos(details.startChangePos + offset, removeDirection);
      if (removeDirection !== DIRECTION.NONE) cursorPos = this.masked.nearestInputPos(cursorPos, DIRECTION.NONE);
      this.updateControl();
      this.updateCursor(cursorPos);
      delete this._inputEvent;
    }

    /** Handles view change event and commits model value */
    _onChange() {
      if (this.displayValue !== this.el.value) {
        this.updateValue();
      }
      this.masked.doCommit();
      this.updateControl();
      this._saveSelection();
    }

    /** Handles view drop event, prevents by default */
    _onDrop(ev) {
      ev.preventDefault();
      ev.stopPropagation();
    }

    /** Restore last selection on focus */
    _onFocus(ev) {
      this.alignCursorFriendly();
    }

    /** Restore last selection on focus */
    _onClick(ev) {
      this.alignCursorFriendly();
    }

    /** Unbind view events and removes element reference */
    destroy() {
      this._unbindEvents();
      this._listeners.length = 0;
      delete this.el;
    }
  }
  IMask.InputMask = InputMask;

  /** Provides details of changing model value */
  class ChangeDetails {
    /** Inserted symbols */

    /** Can skip chars */

    /** Additional offset if any changes occurred before tail */

    /** Raw inserted is used by dynamic mask */

    static normalize(prep) {
      return Array.isArray(prep) ? prep : [prep, new ChangeDetails()];
    }
    constructor(details) {
      Object.assign(this, {
        inserted: '',
        rawInserted: '',
        skip: false,
        tailShift: 0
      }, details);
    }

    /** Aggregate changes */
    aggregate(details) {
      this.rawInserted += details.rawInserted;
      this.skip = this.skip || details.skip;
      this.inserted += details.inserted;
      this.tailShift += details.tailShift;
      return this;
    }

    /** Total offset considering all changes */
    get offset() {
      return this.tailShift + this.inserted.length;
    }
  }
  IMask.ChangeDetails = ChangeDetails;

  /** Provides details of continuous extracted tail */
  class ContinuousTailDetails {
    /** Tail value as string */

    /** Tail start position */

    /** Start position */

    constructor(value, from, stop) {
      if (value === void 0) {
        value = '';
      }
      if (from === void 0) {
        from = 0;
      }
      this.value = value;
      this.from = from;
      this.stop = stop;
    }
    toString() {
      return this.value;
    }
    extend(tail) {
      this.value += String(tail);
    }
    appendTo(masked) {
      return masked.append(this.toString(), {
        tail: true
      }).aggregate(masked._appendPlaceholder());
    }
    get state() {
      return {
        value: this.value,
        from: this.from,
        stop: this.stop
      };
    }
    set state(state) {
      Object.assign(this, state);
    }
    unshift(beforePos) {
      if (!this.value.length || beforePos != null && this.from >= beforePos) return '';
      const shiftChar = this.value[0];
      this.value = this.value.slice(1);
      return shiftChar;
    }
    shift() {
      if (!this.value.length) return '';
      const shiftChar = this.value[this.value.length - 1];
      this.value = this.value.slice(0, -1);
      return shiftChar;
    }
  }

  /** Append flags */

  /** Extract flags */

  // see https://github.com/microsoft/TypeScript/issues/6223

  /** Provides common masking stuff */
  class Masked {
    static DEFAULTS = {
      skipInvalid: true
    };
    static EMPTY_VALUES = [undefined, null, ''];

    /** */

    /** */

    /** Transforms value before mask processing */

    /** Transforms each char before mask processing */

    /** Validates if value is acceptable */

    /** Does additional processing at the end of editing */

    /** Format typed value to string */

    /** Parse string to get typed value */

    /** Enable characters overwriting */

    /** */

    /** */

    /** */

    constructor(opts) {
      this._value = '';
      this._update({
        ...Masked.DEFAULTS,
        ...opts
      });
      this._initialized = true;
    }

    /** Sets and applies new options */
    updateOptions(opts) {
      if (!this.optionsIsChanged(opts)) return;
      this.withValueRefresh(this._update.bind(this, opts));
    }

    /** Sets new options */
    _update(opts) {
      Object.assign(this, opts);
    }

    /** Mask state */
    get state() {
      return {
        _value: this.value,
        _rawInputValue: this.rawInputValue
      };
    }
    set state(state) {
      this._value = state._value;
    }

    /** Resets value */
    reset() {
      this._value = '';
    }
    get value() {
      return this._value;
    }
    set value(value) {
      this.resolve(value, {
        input: true
      });
    }

    /** Resolve new value */
    resolve(value, flags) {
      if (flags === void 0) {
        flags = {
          input: true
        };
      }
      this.reset();
      this.append(value, flags, '');
      this.doCommit();
    }
    get unmaskedValue() {
      return this.value;
    }
    set unmaskedValue(value) {
      this.resolve(value, {});
    }
    get typedValue() {
      return this.parse ? this.parse(this.value, this) : this.unmaskedValue;
    }
    set typedValue(value) {
      if (this.format) {
        this.value = this.format(value, this);
      } else {
        this.unmaskedValue = String(value);
      }
    }

    /** Value that includes raw user input */
    get rawInputValue() {
      return this.extractInput(0, this.displayValue.length, {
        raw: true
      });
    }
    set rawInputValue(value) {
      this.resolve(value, {
        raw: true
      });
    }
    get displayValue() {
      return this.value;
    }
    get isComplete() {
      return true;
    }
    get isFilled() {
      return this.isComplete;
    }

    /** Finds nearest input position in direction */
    nearestInputPos(cursorPos, direction) {
      return cursorPos;
    }
    totalInputPositions(fromPos, toPos) {
      if (fromPos === void 0) {
        fromPos = 0;
      }
      if (toPos === void 0) {
        toPos = this.displayValue.length;
      }
      return Math.min(this.displayValue.length, toPos - fromPos);
    }

    /** Extracts value in range considering flags */
    extractInput(fromPos, toPos, flags) {
      if (fromPos === void 0) {
        fromPos = 0;
      }
      if (toPos === void 0) {
        toPos = this.displayValue.length;
      }
      return this.displayValue.slice(fromPos, toPos);
    }

    /** Extracts tail in range */
    extractTail(fromPos, toPos) {
      if (fromPos === void 0) {
        fromPos = 0;
      }
      if (toPos === void 0) {
        toPos = this.displayValue.length;
      }
      return new ContinuousTailDetails(this.extractInput(fromPos, toPos), fromPos);
    }

    /** Appends tail */
    appendTail(tail) {
      if (isString(tail)) tail = new ContinuousTailDetails(String(tail));
      return tail.appendTo(this);
    }

    /** Appends char */
    _appendCharRaw(ch, flags) {
      if (!ch) return new ChangeDetails();
      this._value += ch;
      return new ChangeDetails({
        inserted: ch,
        rawInserted: ch
      });
    }

    /** Appends char */
    _appendChar(ch, flags, checkTail) {
      if (flags === void 0) {
        flags = {};
      }
      const consistentState = this.state;
      let details;
      [ch, details] = this.doPrepareChar(ch, flags);
      if (ch) details = details.aggregate(this._appendCharRaw(ch, flags));
      if (details.inserted) {
        let consistentTail;
        let appended = this.doValidate(flags) !== false;
        if (appended && checkTail != null) {
          // validation ok, check tail
          const beforeTailState = this.state;
          if (this.overwrite === true) {
            consistentTail = checkTail.state;
            for (let i = 0; i < details.rawInserted.length; ++i) {
              checkTail.unshift(this.displayValue.length - details.tailShift);
            }
          }
          let tailDetails = this.appendTail(checkTail);
          appended = tailDetails.rawInserted.length === checkTail.toString().length;

          // not ok, try shift
          if (!(appended && tailDetails.inserted) && this.overwrite === 'shift') {
            this.state = beforeTailState;
            consistentTail = checkTail.state;
            for (let i = 0; i < details.rawInserted.length; ++i) {
              checkTail.shift();
            }
            tailDetails = this.appendTail(checkTail);
            appended = tailDetails.rawInserted.length === checkTail.toString().length;
          }

          // if ok, rollback state after tail
          if (appended && tailDetails.inserted) this.state = beforeTailState;
        }

        // revert all if something went wrong
        if (!appended) {
          details = new ChangeDetails();
          this.state = consistentState;
          if (checkTail && consistentTail) checkTail.state = consistentTail;
        }
      }
      return details;
    }

    /** Appends optional placeholder at the end */
    _appendPlaceholder() {
      return new ChangeDetails();
    }

    /** Appends optional eager placeholder at the end */
    _appendEager() {
      return new ChangeDetails();
    }

    /** Appends symbols considering flags */
    append(str, flags, tail) {
      if (!isString(str)) throw new Error('value should be string');
      const checkTail = isString(tail) ? new ContinuousTailDetails(String(tail)) : tail;
      if (flags?.tail) flags._beforeTailState = this.state;
      let details;
      [str, details] = this.doPrepare(str, flags);
      for (let ci = 0; ci < str.length; ++ci) {
        const d = this._appendChar(str[ci], flags, checkTail);
        if (!d.rawInserted && !this.doSkipInvalid(str[ci], flags, checkTail)) break;
        details.aggregate(d);
      }
      if ((this.eager === true || this.eager === 'append') && flags?.input && str) {
        details.aggregate(this._appendEager());
      }

      // append tail but aggregate only tailShift
      if (checkTail != null) {
        details.tailShift += this.appendTail(checkTail).tailShift;
        // TODO it's a good idea to clear state after appending ends
        // but it causes bugs when one append calls another (when dynamic dispatch set rawInputValue)
        // this._resetBeforeTailState();
      }
      return details;
    }
    remove(fromPos, toPos) {
      if (fromPos === void 0) {
        fromPos = 0;
      }
      if (toPos === void 0) {
        toPos = this.displayValue.length;
      }
      this._value = this.displayValue.slice(0, fromPos) + this.displayValue.slice(toPos);
      return new ChangeDetails();
    }

    /** Calls function and reapplies current value */
    withValueRefresh(fn) {
      if (this._refreshing || !this._initialized) return fn();
      this._refreshing = true;
      const rawInput = this.rawInputValue;
      const value = this.value;
      const ret = fn();
      this.rawInputValue = rawInput;
      // append lost trailing chars at the end
      if (this.value && this.value !== value && value.indexOf(this.value) === 0) {
        this.append(value.slice(this.displayValue.length), {}, '');
        this.doCommit();
      }
      delete this._refreshing;
      return ret;
    }
    runIsolated(fn) {
      if (this._isolated || !this._initialized) return fn(this);
      this._isolated = true;
      const state = this.state;
      const ret = fn(this);
      this.state = state;
      delete this._isolated;
      return ret;
    }
    doSkipInvalid(ch, flags, checkTail) {
      return Boolean(this.skipInvalid);
    }

    /** Prepares string before mask processing */
    doPrepare(str, flags) {
      if (flags === void 0) {
        flags = {};
      }
      return ChangeDetails.normalize(this.prepare ? this.prepare(str, this, flags) : str);
    }

    /** Prepares each char before mask processing */
    doPrepareChar(str, flags) {
      if (flags === void 0) {
        flags = {};
      }
      return ChangeDetails.normalize(this.prepareChar ? this.prepareChar(str, this, flags) : str);
    }

    /** Validates if value is acceptable */
    doValidate(flags) {
      return (!this.validate || this.validate(this.value, this, flags)) && (!this.parent || this.parent.doValidate(flags));
    }

    /** Does additional processing at the end of editing */
    doCommit() {
      if (this.commit) this.commit(this.value, this);
    }
    splice(start, deleteCount, inserted, removeDirection, flags) {
      if (removeDirection === void 0) {
        removeDirection = DIRECTION.NONE;
      }
      if (flags === void 0) {
        flags = {
          input: true
        };
      }
      const tailPos = start + deleteCount;
      const tail = this.extractTail(tailPos);
      const eagerRemove = this.eager === true || this.eager === 'remove';
      let oldRawValue;
      if (eagerRemove) {
        removeDirection = forceDirection(removeDirection);
        oldRawValue = this.extractInput(0, tailPos, {
          raw: true
        });
      }
      let startChangePos = start;
      const details = new ChangeDetails();

      // if it is just deletion without insertion
      if (removeDirection !== DIRECTION.NONE) {
        startChangePos = this.nearestInputPos(start, deleteCount > 1 && start !== 0 && !eagerRemove ? DIRECTION.NONE : removeDirection);

        // adjust tailShift if start was aligned
        details.tailShift = startChangePos - start;
      }
      details.aggregate(this.remove(startChangePos));
      if (eagerRemove && removeDirection !== DIRECTION.NONE && oldRawValue === this.rawInputValue) {
        if (removeDirection === DIRECTION.FORCE_LEFT) {
          let valLength;
          while (oldRawValue === this.rawInputValue && (valLength = this.displayValue.length)) {
            details.aggregate(new ChangeDetails({
              tailShift: -1
            })).aggregate(this.remove(valLength - 1));
          }
        } else if (removeDirection === DIRECTION.FORCE_RIGHT) {
          tail.unshift();
        }
      }
      return details.aggregate(this.append(inserted, flags, tail));
    }
    maskEquals(mask) {
      return this.mask === mask;
    }
    optionsIsChanged(opts) {
      return !objectIncludes(this, opts);
    }
    typedValueEquals(value) {
      const tval = this.typedValue;
      return value === tval || Masked.EMPTY_VALUES.includes(value) && Masked.EMPTY_VALUES.includes(tval) || (this.format ? this.format(value, this) === this.format(this.typedValue, this) : false);
    }
  }
  IMask.Masked = Masked;

  class ChunksTailDetails {
    /** */

    constructor(chunks, from) {
      if (chunks === void 0) {
        chunks = [];
      }
      if (from === void 0) {
        from = 0;
      }
      this.chunks = chunks;
      this.from = from;
    }
    toString() {
      return this.chunks.map(String).join('');
    }
    extend(tailChunk) {
      if (!String(tailChunk)) return;
      tailChunk = isString(tailChunk) ? new ContinuousTailDetails(String(tailChunk)) : tailChunk;
      const lastChunk = this.chunks[this.chunks.length - 1];
      const extendLast = lastChunk && (
      // if stops are same or tail has no stop
      lastChunk.stop === tailChunk.stop || tailChunk.stop == null) &&
      // if tail chunk goes just after last chunk
      tailChunk.from === lastChunk.from + lastChunk.toString().length;
      if (tailChunk instanceof ContinuousTailDetails) {
        // check the ability to extend previous chunk
        if (extendLast) {
          // extend previous chunk
          lastChunk.extend(tailChunk.toString());
        } else {
          // append new chunk
          this.chunks.push(tailChunk);
        }
      } else if (tailChunk instanceof ChunksTailDetails) {
        if (tailChunk.stop == null) {
          // unwrap floating chunks to parent, keeping `from` pos
          let firstTailChunk;
          while (tailChunk.chunks.length && tailChunk.chunks[0].stop == null) {
            firstTailChunk = tailChunk.chunks.shift(); // not possible to be `undefined` because length was checked above
            firstTailChunk.from += tailChunk.from;
            this.extend(firstTailChunk);
          }
        }

        // if tail chunk still has value
        if (tailChunk.toString()) {
          // if chunks contains stops, then popup stop to container
          tailChunk.stop = tailChunk.blockIndex;
          this.chunks.push(tailChunk);
        }
      }
    }
    appendTo(masked) {
      if (!(masked instanceof IMask.MaskedPattern)) {
        const tail = new ContinuousTailDetails(this.toString());
        return tail.appendTo(masked);
      }
      const details = new ChangeDetails();
      for (let ci = 0; ci < this.chunks.length && !details.skip; ++ci) {
        const chunk = this.chunks[ci];
        const lastBlockIter = masked._mapPosToBlock(masked.displayValue.length);
        const stop = chunk.stop;
        let chunkBlock;
        if (stop != null && (
        // if block not found or stop is behind lastBlock
        !lastBlockIter || lastBlockIter.index <= stop)) {
          if (chunk instanceof ChunksTailDetails ||
          // for continuous block also check if stop is exist
          masked._stops.indexOf(stop) >= 0) {
            const phDetails = masked._appendPlaceholder(stop);
            details.aggregate(phDetails);
          }
          chunkBlock = chunk instanceof ChunksTailDetails && masked._blocks[stop];
        }
        if (chunkBlock) {
          const tailDetails = chunkBlock.appendTail(chunk);
          tailDetails.skip = false; // always ignore skip, it will be set on last
          details.aggregate(tailDetails);
          masked._value += tailDetails.inserted;

          // get not inserted chars
          const remainChars = chunk.toString().slice(tailDetails.rawInserted.length);
          if (remainChars) details.aggregate(masked.append(remainChars, {
            tail: true
          }));
        } else {
          details.aggregate(masked.append(chunk.toString(), {
            tail: true
          }));
        }
      }
      return details;
    }
    get state() {
      return {
        chunks: this.chunks.map(c => c.state),
        from: this.from,
        stop: this.stop,
        blockIndex: this.blockIndex
      };
    }
    set state(state) {
      const {
        chunks,
        ...props
      } = state;
      Object.assign(this, props);
      this.chunks = chunks.map(cstate => {
        const chunk = "chunks" in cstate ? new ChunksTailDetails() : new ContinuousTailDetails();
        chunk.state = cstate;
        return chunk;
      });
    }
    unshift(beforePos) {
      if (!this.chunks.length || beforePos != null && this.from >= beforePos) return '';
      const chunkShiftPos = beforePos != null ? beforePos - this.from : beforePos;
      let ci = 0;
      while (ci < this.chunks.length) {
        const chunk = this.chunks[ci];
        const shiftChar = chunk.unshift(chunkShiftPos);
        if (chunk.toString()) {
          // chunk still contains value
          // but not shifted - means no more available chars to shift
          if (!shiftChar) break;
          ++ci;
        } else {
          // clean if chunk has no value
          this.chunks.splice(ci, 1);
        }
        if (shiftChar) return shiftChar;
      }
      return '';
    }
    shift() {
      if (!this.chunks.length) return '';
      let ci = this.chunks.length - 1;
      while (0 <= ci) {
        const chunk = this.chunks[ci];
        const shiftChar = chunk.shift();
        if (chunk.toString()) {
          // chunk still contains value
          // but not shifted - means no more available chars to shift
          if (!shiftChar) break;
          --ci;
        } else {
          // clean if chunk has no value
          this.chunks.splice(ci, 1);
        }
        if (shiftChar) return shiftChar;
      }
      return '';
    }
  }

  class PatternCursor {
    constructor(masked, pos) {
      this.masked = masked;
      this._log = [];
      const {
        offset,
        index
      } = masked._mapPosToBlock(pos) || (pos < 0 ?
      // first
      {
        index: 0,
        offset: 0
      } :
      // last
      {
        index: this.masked._blocks.length,
        offset: 0
      });
      this.offset = offset;
      this.index = index;
      this.ok = false;
    }
    get block() {
      return this.masked._blocks[this.index];
    }
    get pos() {
      return this.masked._blockStartPos(this.index) + this.offset;
    }
    get state() {
      return {
        index: this.index,
        offset: this.offset,
        ok: this.ok
      };
    }
    set state(s) {
      Object.assign(this, s);
    }
    pushState() {
      this._log.push(this.state);
    }
    popState() {
      const s = this._log.pop();
      if (s) this.state = s;
      return s;
    }
    bindBlock() {
      if (this.block) return;
      if (this.index < 0) {
        this.index = 0;
        this.offset = 0;
      }
      if (this.index >= this.masked._blocks.length) {
        this.index = this.masked._blocks.length - 1;
        this.offset = this.block.displayValue.length; // TODO this is stupid type error, `block` depends on index that was changed above
      }
    }
    _pushLeft(fn) {
      this.pushState();
      for (this.bindBlock(); 0 <= this.index; --this.index, this.offset = this.block?.displayValue.length || 0) {
        if (fn()) return this.ok = true;
      }
      return this.ok = false;
    }
    _pushRight(fn) {
      this.pushState();
      for (this.bindBlock(); this.index < this.masked._blocks.length; ++this.index, this.offset = 0) {
        if (fn()) return this.ok = true;
      }
      return this.ok = false;
    }
    pushLeftBeforeFilled() {
      return this._pushLeft(() => {
        if (this.block.isFixed || !this.block.value) return;
        this.offset = this.block.nearestInputPos(this.offset, DIRECTION.FORCE_LEFT);
        if (this.offset !== 0) return true;
      });
    }
    pushLeftBeforeInput() {
      // cases:
      // filled input: 00|
      // optional empty input: 00[]|
      // nested block: XX<[]>|
      return this._pushLeft(() => {
        if (this.block.isFixed) return;
        this.offset = this.block.nearestInputPos(this.offset, DIRECTION.LEFT);
        return true;
      });
    }
    pushLeftBeforeRequired() {
      return this._pushLeft(() => {
        if (this.block.isFixed || this.block.isOptional && !this.block.value) return;
        this.offset = this.block.nearestInputPos(this.offset, DIRECTION.LEFT);
        return true;
      });
    }
    pushRightBeforeFilled() {
      return this._pushRight(() => {
        if (this.block.isFixed || !this.block.value) return;
        this.offset = this.block.nearestInputPos(this.offset, DIRECTION.FORCE_RIGHT);
        if (this.offset !== this.block.value.length) return true;
      });
    }
    pushRightBeforeInput() {
      return this._pushRight(() => {
        if (this.block.isFixed) return;

        // const o = this.offset;
        this.offset = this.block.nearestInputPos(this.offset, DIRECTION.NONE);
        // HACK cases like (STILL DOES NOT WORK FOR NESTED)
        // aa|X
        // aa<X|[]>X_    - this will not work
        // if (o && o === this.offset && this.block instanceof PatternInputDefinition) continue;
        return true;
      });
    }
    pushRightBeforeRequired() {
      return this._pushRight(() => {
        if (this.block.isFixed || this.block.isOptional && !this.block.value) return;

        // TODO check |[*]XX_
        this.offset = this.block.nearestInputPos(this.offset, DIRECTION.NONE);
        return true;
      });
    }
  }

  class PatternFixedDefinition {
    /** */

    /** */

    /** */

    /** */

    /** */

    /** */

    constructor(opts) {
      Object.assign(this, opts);
      this._value = '';
      this.isFixed = true;
    }
    get value() {
      return this._value;
    }
    get unmaskedValue() {
      return this.isUnmasking ? this.value : '';
    }
    get rawInputValue() {
      return this._isRawInput ? this.value : '';
    }
    get displayValue() {
      return this.value;
    }
    reset() {
      this._isRawInput = false;
      this._value = '';
    }
    remove(fromPos, toPos) {
      if (fromPos === void 0) {
        fromPos = 0;
      }
      if (toPos === void 0) {
        toPos = this._value.length;
      }
      this._value = this._value.slice(0, fromPos) + this._value.slice(toPos);
      if (!this._value) this._isRawInput = false;
      return new ChangeDetails();
    }
    nearestInputPos(cursorPos, direction) {
      if (direction === void 0) {
        direction = DIRECTION.NONE;
      }
      const minPos = 0;
      const maxPos = this._value.length;
      switch (direction) {
        case DIRECTION.LEFT:
        case DIRECTION.FORCE_LEFT:
          return minPos;
        case DIRECTION.NONE:
        case DIRECTION.RIGHT:
        case DIRECTION.FORCE_RIGHT:
        default:
          return maxPos;
      }
    }
    totalInputPositions(fromPos, toPos) {
      if (fromPos === void 0) {
        fromPos = 0;
      }
      if (toPos === void 0) {
        toPos = this._value.length;
      }
      return this._isRawInput ? toPos - fromPos : 0;
    }
    extractInput(fromPos, toPos, flags) {
      if (fromPos === void 0) {
        fromPos = 0;
      }
      if (toPos === void 0) {
        toPos = this._value.length;
      }
      if (flags === void 0) {
        flags = {};
      }
      return flags.raw && this._isRawInput && this._value.slice(fromPos, toPos) || '';
    }
    get isComplete() {
      return true;
    }
    get isFilled() {
      return Boolean(this._value);
    }
    _appendChar(ch, flags) {
      if (flags === void 0) {
        flags = {};
      }
      const details = new ChangeDetails();
      if (this.isFilled) return details;
      const appendEager = this.eager === true || this.eager === 'append';
      const appended = this.char === ch;
      const isResolved = appended && (this.isUnmasking || flags.input || flags.raw) && (!flags.raw || !appendEager) && !flags.tail;
      if (isResolved) details.rawInserted = this.char;
      this._value = details.inserted = this.char;
      this._isRawInput = isResolved && (flags.raw || flags.input);
      return details;
    }
    _appendEager() {
      return this._appendChar(this.char, {
        tail: true
      });
    }
    _appendPlaceholder() {
      const details = new ChangeDetails();
      if (this.isFilled) return details;
      this._value = details.inserted = this.char;
      return details;
    }
    extractTail() {
      return new ContinuousTailDetails('');
    }
    appendTail(tail) {
      if (isString(tail)) tail = new ContinuousTailDetails(String(tail));
      return tail.appendTo(this);
    }
    append(str, flags, tail) {
      const details = this._appendChar(str[0], flags);
      if (tail != null) {
        details.tailShift += this.appendTail(tail).tailShift;
      }
      return details;
    }
    doCommit() {}
    get state() {
      return {
        _value: this._value,
        _rawInputValue: this.rawInputValue
      };
    }
    set state(state) {
      this._value = state._value;
      this._isRawInput = Boolean(state._rawInputValue);
    }
  }

  class PatternInputDefinition {
    static DEFAULT_DEFINITIONS = {
      '0': /\d/,
      'a': /[\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
      // http://stackoverflow.com/a/22075070
      '*': /./
    };

    /** */

    /** */

    /** */

    /** */

    /** */

    /** */

    /** */

    /** */

    constructor(opts) {
      const {
        parent,
        isOptional,
        placeholderChar,
        displayChar,
        lazy,
        eager,
        ...maskOpts
      } = opts;
      this.masked = createMask(maskOpts);
      Object.assign(this, {
        parent,
        isOptional,
        placeholderChar,
        displayChar,
        lazy,
        eager
      });
    }
    reset() {
      this.isFilled = false;
      this.masked.reset();
    }
    remove(fromPos, toPos) {
      if (fromPos === void 0) {
        fromPos = 0;
      }
      if (toPos === void 0) {
        toPos = this.value.length;
      }
      if (fromPos === 0 && toPos >= 1) {
        this.isFilled = false;
        return this.masked.remove(fromPos, toPos);
      }
      return new ChangeDetails();
    }
    get value() {
      return this.masked.value || (this.isFilled && !this.isOptional ? this.placeholderChar : '');
    }
    get unmaskedValue() {
      return this.masked.unmaskedValue;
    }
    get rawInputValue() {
      return this.masked.rawInputValue;
    }
    get displayValue() {
      return this.masked.value && this.displayChar || this.value;
    }
    get isComplete() {
      return Boolean(this.masked.value) || this.isOptional;
    }
    _appendChar(ch, flags) {
      if (flags === void 0) {
        flags = {};
      }
      if (this.isFilled) return new ChangeDetails();
      const state = this.masked.state;
      // simulate input
      const details = this.masked._appendChar(ch, this.currentMaskFlags(flags));
      if (details.inserted && this.doValidate(flags) === false) {
        details.inserted = details.rawInserted = '';
        this.masked.state = state;
      }
      if (!details.inserted && !this.isOptional && !this.lazy && !flags.input) {
        details.inserted = this.placeholderChar;
      }
      details.skip = !details.inserted && !this.isOptional;
      this.isFilled = Boolean(details.inserted);
      return details;
    }
    append(str, flags, tail) {
      // TODO probably should be done via _appendChar
      return this.masked.append(str, this.currentMaskFlags(flags), tail);
    }
    _appendPlaceholder() {
      const details = new ChangeDetails();
      if (this.isFilled || this.isOptional) return details;
      this.isFilled = true;
      details.inserted = this.placeholderChar;
      return details;
    }
    _appendEager() {
      return new ChangeDetails();
    }
    extractTail(fromPos, toPos) {
      return this.masked.extractTail(fromPos, toPos);
    }
    appendTail(tail) {
      return this.masked.appendTail(tail);
    }
    extractInput(fromPos, toPos, flags) {
      if (fromPos === void 0) {
        fromPos = 0;
      }
      if (toPos === void 0) {
        toPos = this.value.length;
      }
      return this.masked.extractInput(fromPos, toPos, flags);
    }
    nearestInputPos(cursorPos, direction) {
      if (direction === void 0) {
        direction = DIRECTION.NONE;
      }
      const minPos = 0;
      const maxPos = this.value.length;
      const boundPos = Math.min(Math.max(cursorPos, minPos), maxPos);
      switch (direction) {
        case DIRECTION.LEFT:
        case DIRECTION.FORCE_LEFT:
          return this.isComplete ? boundPos : minPos;
        case DIRECTION.RIGHT:
        case DIRECTION.FORCE_RIGHT:
          return this.isComplete ? boundPos : maxPos;
        case DIRECTION.NONE:
        default:
          return boundPos;
      }
    }
    totalInputPositions(fromPos, toPos) {
      if (fromPos === void 0) {
        fromPos = 0;
      }
      if (toPos === void 0) {
        toPos = this.value.length;
      }
      return this.value.slice(fromPos, toPos).length;
    }
    doValidate(flags) {
      return this.masked.doValidate(this.currentMaskFlags(flags)) && (!this.parent || this.parent.doValidate(this.currentMaskFlags(flags)));
    }
    doCommit() {
      this.masked.doCommit();
    }
    get state() {
      return {
        _value: this.value,
        _rawInputValue: this.rawInputValue,
        masked: this.masked.state,
        isFilled: this.isFilled
      };
    }
    set state(state) {
      this.masked.state = state.masked;
      this.isFilled = state.isFilled;
    }
    currentMaskFlags(flags) {
      return {
        ...flags,
        _beforeTailState: flags?._beforeTailState?.masked || flags?._beforeTailState
      };
    }
  }

  /** Masking by RegExp */
  class MaskedRegExp extends Masked {
    /** */

    /** Enable characters overwriting */

    /** */

    /** */

    updateOptions(opts) {
      super.updateOptions(opts);
    }
    _update(opts) {
      const mask = opts.mask;
      if (mask) opts.validate = value => value.search(mask) >= 0;
      super._update(opts);
    }
  }
  IMask.MaskedRegExp = MaskedRegExp;

  /** Pattern mask */
  class MaskedPattern extends Masked {
    static DEFAULTS = {
      lazy: true,
      placeholderChar: '_'
    };
    static STOP_CHAR = '`';
    static ESCAPE_CHAR = '\\';
    static InputDefinition = PatternInputDefinition;
    static FixedDefinition = PatternFixedDefinition;

    /** */

    /** */

    /** Single char for empty input */

    /** Single char for filled input */

    /** Show placeholder only when needed */

    /** Enable characters overwriting */

    /** */

    /** */

    constructor(opts) {
      super({
        ...MaskedPattern.DEFAULTS,
        ...opts,
        definitions: Object.assign({}, PatternInputDefinition.DEFAULT_DEFINITIONS, opts?.definitions)
      });
    }
    updateOptions(opts) {
      super.updateOptions(opts);
    }
    _update(opts) {
      opts.definitions = Object.assign({}, this.definitions, opts.definitions);
      super._update(opts);
      this._rebuildMask();
    }
    _rebuildMask() {
      const defs = this.definitions;
      this._blocks = [];
      this.exposeBlock = undefined;
      this._stops = [];
      this._maskedBlocks = {};
      const pattern = this.mask;
      if (!pattern || !defs) return;
      let unmaskingBlock = false;
      let optionalBlock = false;
      for (let i = 0; i < pattern.length; ++i) {
        if (this.blocks) {
          const p = pattern.slice(i);
          const bNames = Object.keys(this.blocks).filter(bName => p.indexOf(bName) === 0);
          // order by key length
          bNames.sort((a, b) => b.length - a.length);
          // use block name with max length
          const bName = bNames[0];
          if (bName) {
            const {
              expose,
              ...blockOpts
            } = normalizeOpts(this.blocks[bName]);
            const maskedBlock = createMask({
              lazy: this.lazy,
              eager: this.eager,
              placeholderChar: this.placeholderChar,
              displayChar: this.displayChar,
              overwrite: this.overwrite,
              ...blockOpts,
              parent: this
            });
            if (maskedBlock) {
              this._blocks.push(maskedBlock);
              if (expose) this.exposeBlock = maskedBlock;

              // store block index
              if (!this._maskedBlocks[bName]) this._maskedBlocks[bName] = [];
              this._maskedBlocks[bName].push(this._blocks.length - 1);
            }
            i += bName.length - 1;
            continue;
          }
        }
        let char = pattern[i];
        let isInput = (char in defs);
        if (char === MaskedPattern.STOP_CHAR) {
          this._stops.push(this._blocks.length);
          continue;
        }
        if (char === '{' || char === '}') {
          unmaskingBlock = !unmaskingBlock;
          continue;
        }
        if (char === '[' || char === ']') {
          optionalBlock = !optionalBlock;
          continue;
        }
        if (char === MaskedPattern.ESCAPE_CHAR) {
          ++i;
          char = pattern[i];
          if (!char) break;
          isInput = false;
        }
        const def = isInput ? new PatternInputDefinition({
          isOptional: optionalBlock,
          lazy: this.lazy,
          eager: this.eager,
          placeholderChar: this.placeholderChar,
          displayChar: this.displayChar,
          ...normalizeOpts(defs[char]),
          parent: this
        }) : new PatternFixedDefinition({
          char,
          eager: this.eager,
          isUnmasking: unmaskingBlock
        });
        this._blocks.push(def);
      }
    }
    get state() {
      return {
        ...super.state,
        _blocks: this._blocks.map(b => b.state)
      };
    }
    set state(state) {
      const {
        _blocks,
        ...maskedState
      } = state;
      this._blocks.forEach((b, bi) => b.state = _blocks[bi]);
      super.state = maskedState;
    }
    reset() {
      super.reset();
      this._blocks.forEach(b => b.reset());
    }
    get isComplete() {
      return this.exposeBlock ? this.exposeBlock.isComplete : this._blocks.every(b => b.isComplete);
    }
    get isFilled() {
      return this._blocks.every(b => b.isFilled);
    }
    get isFixed() {
      return this._blocks.every(b => b.isFixed);
    }
    get isOptional() {
      return this._blocks.every(b => b.isOptional);
    }
    doCommit() {
      this._blocks.forEach(b => b.doCommit());
      super.doCommit();
    }
    get unmaskedValue() {
      return this.exposeBlock ? this.exposeBlock.unmaskedValue : this._blocks.reduce((str, b) => str += b.unmaskedValue, '');
    }
    set unmaskedValue(unmaskedValue) {
      if (this.exposeBlock) {
        const tail = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);
        this.exposeBlock.unmaskedValue = unmaskedValue;
        this.appendTail(tail);
        this.doCommit();
      } else super.unmaskedValue = unmaskedValue;
    }
    get value() {
      return this.exposeBlock ? this.exposeBlock.value :
      // TODO return _value when not in change?
      this._blocks.reduce((str, b) => str += b.value, '');
    }
    set value(value) {
      if (this.exposeBlock) {
        const tail = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);
        this.exposeBlock.value = value;
        this.appendTail(tail);
        this.doCommit();
      } else super.value = value;
    }
    get typedValue() {
      return this.exposeBlock ? this.exposeBlock.typedValue : super.typedValue;
    }
    set typedValue(value) {
      if (this.exposeBlock) {
        const tail = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);
        this.exposeBlock.typedValue = value;
        this.appendTail(tail);
        this.doCommit();
      } else super.typedValue = value;
    }
    get displayValue() {
      return this._blocks.reduce((str, b) => str += b.displayValue, '');
    }
    appendTail(tail) {
      return super.appendTail(tail).aggregate(this._appendPlaceholder());
    }
    _appendEager() {
      const details = new ChangeDetails();
      let startBlockIndex = this._mapPosToBlock(this.displayValue.length)?.index;
      if (startBlockIndex == null) return details;

      // TODO test if it works for nested pattern masks
      if (this._blocks[startBlockIndex].isFilled) ++startBlockIndex;
      for (let bi = startBlockIndex; bi < this._blocks.length; ++bi) {
        const d = this._blocks[bi]._appendEager();
        if (!d.inserted) break;
        details.aggregate(d);
      }
      return details;
    }
    _appendCharRaw(ch, flags) {
      if (flags === void 0) {
        flags = {};
      }
      const blockIter = this._mapPosToBlock(this.displayValue.length);
      const details = new ChangeDetails();
      if (!blockIter) return details;
      for (let bi = blockIter.index, block; block = this._blocks[bi]; ++bi) {
        const blockDetails = block._appendChar(ch, {
          ...flags,
          _beforeTailState: flags._beforeTailState?._blocks?.[bi]
        });
        const skip = blockDetails.skip;
        details.aggregate(blockDetails);
        if (skip || blockDetails.rawInserted) break; // go next char
      }
      return details;
    }
    extractTail(fromPos, toPos) {
      if (fromPos === void 0) {
        fromPos = 0;
      }
      if (toPos === void 0) {
        toPos = this.displayValue.length;
      }
      const chunkTail = new ChunksTailDetails();
      if (fromPos === toPos) return chunkTail;
      this._forEachBlocksInRange(fromPos, toPos, (b, bi, bFromPos, bToPos) => {
        const blockChunk = b.extractTail(bFromPos, bToPos);
        blockChunk.stop = this._findStopBefore(bi);
        blockChunk.from = this._blockStartPos(bi);
        if (blockChunk instanceof ChunksTailDetails) blockChunk.blockIndex = bi;
        chunkTail.extend(blockChunk);
      });
      return chunkTail;
    }
    extractInput(fromPos, toPos, flags) {
      if (fromPos === void 0) {
        fromPos = 0;
      }
      if (toPos === void 0) {
        toPos = this.displayValue.length;
      }
      if (flags === void 0) {
        flags = {};
      }
      if (fromPos === toPos) return '';
      let input = '';
      this._forEachBlocksInRange(fromPos, toPos, (b, _, fromPos, toPos) => {
        input += b.extractInput(fromPos, toPos, flags);
      });
      return input;
    }
    _findStopBefore(blockIndex) {
      let stopBefore;
      for (let si = 0; si < this._stops.length; ++si) {
        const stop = this._stops[si];
        if (stop <= blockIndex) stopBefore = stop;else break;
      }
      return stopBefore;
    }

    /** Appends placeholder depending on laziness */
    _appendPlaceholder(toBlockIndex) {
      const details = new ChangeDetails();
      if (this.lazy && toBlockIndex == null) return details;
      const startBlockIter = this._mapPosToBlock(this.displayValue.length);
      if (!startBlockIter) return details;
      const startBlockIndex = startBlockIter.index;
      const endBlockIndex = toBlockIndex != null ? toBlockIndex : this._blocks.length;
      this._blocks.slice(startBlockIndex, endBlockIndex).forEach(b => {
        if (!b.lazy || toBlockIndex != null) {
          const bDetails = b._appendPlaceholder(b._blocks?.length);
          this._value += bDetails.inserted;
          details.aggregate(bDetails);
        }
      });
      return details;
    }

    /** Finds block in pos */
    _mapPosToBlock(pos) {
      let accVal = '';
      for (let bi = 0; bi < this._blocks.length; ++bi) {
        const block = this._blocks[bi];
        const blockStartPos = accVal.length;
        accVal += block.displayValue;
        if (pos <= accVal.length) {
          return {
            index: bi,
            offset: pos - blockStartPos
          };
        }
      }
    }
    _blockStartPos(blockIndex) {
      return this._blocks.slice(0, blockIndex).reduce((pos, b) => pos += b.displayValue.length, 0);
    }
    _forEachBlocksInRange(fromPos, toPos, fn) {
      if (toPos === void 0) {
        toPos = this.displayValue.length;
      }
      const fromBlockIter = this._mapPosToBlock(fromPos);
      if (fromBlockIter) {
        const toBlockIter = this._mapPosToBlock(toPos);
        // process first block
        const isSameBlock = toBlockIter && fromBlockIter.index === toBlockIter.index;
        const fromBlockStartPos = fromBlockIter.offset;
        const fromBlockEndPos = toBlockIter && isSameBlock ? toBlockIter.offset : this._blocks[fromBlockIter.index].displayValue.length;
        fn(this._blocks[fromBlockIter.index], fromBlockIter.index, fromBlockStartPos, fromBlockEndPos);
        if (toBlockIter && !isSameBlock) {
          // process intermediate blocks
          for (let bi = fromBlockIter.index + 1; bi < toBlockIter.index; ++bi) {
            fn(this._blocks[bi], bi, 0, this._blocks[bi].displayValue.length);
          }

          // process last block
          fn(this._blocks[toBlockIter.index], toBlockIter.index, 0, toBlockIter.offset);
        }
      }
    }
    remove(fromPos, toPos) {
      if (fromPos === void 0) {
        fromPos = 0;
      }
      if (toPos === void 0) {
        toPos = this.displayValue.length;
      }
      const removeDetails = super.remove(fromPos, toPos);
      this._forEachBlocksInRange(fromPos, toPos, (b, _, bFromPos, bToPos) => {
        removeDetails.aggregate(b.remove(bFromPos, bToPos));
      });
      return removeDetails;
    }
    nearestInputPos(cursorPos, direction) {
      if (direction === void 0) {
        direction = DIRECTION.NONE;
      }
      if (!this._blocks.length) return 0;
      const cursor = new PatternCursor(this, cursorPos);
      if (direction === DIRECTION.NONE) {
        // -------------------------------------------------
        // NONE should only go out from fixed to the right!
        // -------------------------------------------------
        if (cursor.pushRightBeforeInput()) return cursor.pos;
        cursor.popState();
        if (cursor.pushLeftBeforeInput()) return cursor.pos;
        return this.displayValue.length;
      }

      // FORCE is only about a|* otherwise is 0
      if (direction === DIRECTION.LEFT || direction === DIRECTION.FORCE_LEFT) {
        // try to break fast when *|a
        if (direction === DIRECTION.LEFT) {
          cursor.pushRightBeforeFilled();
          if (cursor.ok && cursor.pos === cursorPos) return cursorPos;
          cursor.popState();
        }

        // forward flow
        cursor.pushLeftBeforeInput();
        cursor.pushLeftBeforeRequired();
        cursor.pushLeftBeforeFilled();

        // backward flow
        if (direction === DIRECTION.LEFT) {
          cursor.pushRightBeforeInput();
          cursor.pushRightBeforeRequired();
          if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;
          cursor.popState();
          if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;
          cursor.popState();
        }
        if (cursor.ok) return cursor.pos;
        if (direction === DIRECTION.FORCE_LEFT) return 0;
        cursor.popState();
        if (cursor.ok) return cursor.pos;
        cursor.popState();
        if (cursor.ok) return cursor.pos;
        return 0;
      }
      if (direction === DIRECTION.RIGHT || direction === DIRECTION.FORCE_RIGHT) {
        // forward flow
        cursor.pushRightBeforeInput();
        cursor.pushRightBeforeRequired();
        if (cursor.pushRightBeforeFilled()) return cursor.pos;
        if (direction === DIRECTION.FORCE_RIGHT) return this.displayValue.length;

        // backward flow
        cursor.popState();
        if (cursor.ok) return cursor.pos;
        cursor.popState();
        if (cursor.ok) return cursor.pos;
        return this.nearestInputPos(cursorPos, DIRECTION.LEFT);
      }
      return cursorPos;
    }
    totalInputPositions(fromPos, toPos) {
      if (fromPos === void 0) {
        fromPos = 0;
      }
      if (toPos === void 0) {
        toPos = this.displayValue.length;
      }
      let total = 0;
      this._forEachBlocksInRange(fromPos, toPos, (b, _, bFromPos, bToPos) => {
        total += b.totalInputPositions(bFromPos, bToPos);
      });
      return total;
    }

    /** Get block by name */
    maskedBlock(name) {
      return this.maskedBlocks(name)[0];
    }

    /** Get all blocks by name */
    maskedBlocks(name) {
      const indices = this._maskedBlocks[name];
      if (!indices) return [];
      return indices.map(gi => this._blocks[gi]);
    }
  }
  IMask.MaskedPattern = MaskedPattern;

  /** Pattern which accepts ranges */
  class MaskedRange extends MaskedPattern {
    /**
      Optionally sets max length of pattern.
      Used when pattern length is longer then `to` param length. Pads zeros at start in this case.
    */

    /** Min bound */

    /** Max bound */

    /** */

    get _matchFrom() {
      return this.maxLength - String(this.from).length;
    }
    constructor(opts) {
      super(opts); // mask will be created in _update
    }
    updateOptions(opts) {
      super.updateOptions(opts);
    }
    _update(opts) {
      const {
        to = this.to || 0,
        from = this.from || 0,
        maxLength = this.maxLength || 0,
        autofix = this.autofix,
        ...patternOpts
      } = opts;
      this.to = to;
      this.from = from;
      this.maxLength = Math.max(String(to).length, maxLength);
      this.autofix = autofix;
      const fromStr = String(this.from).padStart(this.maxLength, '0');
      const toStr = String(this.to).padStart(this.maxLength, '0');
      let sameCharsCount = 0;
      while (sameCharsCount < toStr.length && toStr[sameCharsCount] === fromStr[sameCharsCount]) ++sameCharsCount;
      patternOpts.mask = toStr.slice(0, sameCharsCount).replace(/0/g, '\\0') + '0'.repeat(this.maxLength - sameCharsCount);
      super._update(patternOpts);
    }
    get isComplete() {
      return super.isComplete && Boolean(this.value);
    }
    boundaries(str) {
      let minstr = '';
      let maxstr = '';
      const [, placeholder, num] = str.match(/^(\D*)(\d*)(\D*)/) || [];
      if (num) {
        minstr = '0'.repeat(placeholder.length) + num;
        maxstr = '9'.repeat(placeholder.length) + num;
      }
      minstr = minstr.padEnd(this.maxLength, '0');
      maxstr = maxstr.padEnd(this.maxLength, '9');
      return [minstr, maxstr];
    }
    doPrepareChar(ch, flags) {
      if (flags === void 0) {
        flags = {};
      }
      let details;
      [ch, details] = super.doPrepareChar(ch.replace(/\D/g, ''), flags);
      if (!this.autofix || !ch) return [ch, details];
      const fromStr = String(this.from).padStart(this.maxLength, '0');
      const toStr = String(this.to).padStart(this.maxLength, '0');
      const nextVal = this.value + ch;
      if (nextVal.length > this.maxLength) return ['', details];
      const [minstr, maxstr] = this.boundaries(nextVal);
      if (Number(maxstr) < this.from) return [fromStr[nextVal.length - 1], details];
      if (Number(minstr) > this.to) {
        if (this.autofix === 'pad' && nextVal.length < this.maxLength) {
          return ['', details.aggregate(this.append(fromStr[nextVal.length - 1] + ch, flags))];
        }
        return [toStr[nextVal.length - 1], details];
      }
      return [ch, details];
    }
    doValidate(flags) {
      const str = this.value;
      const firstNonZero = str.search(/[^0]/);
      if (firstNonZero === -1 && str.length <= this._matchFrom) return true;
      const [minstr, maxstr] = this.boundaries(str);
      return this.from <= Number(maxstr) && Number(minstr) <= this.to && super.doValidate(flags);
    }
  }
  IMask.MaskedRange = MaskedRange;

  /** Date mask */
  class MaskedDate extends MaskedPattern {
    static GET_DEFAULT_BLOCKS = () => ({
      d: {
        mask: MaskedRange,
        from: 1,
        to: 31,
        maxLength: 2
      },
      m: {
        mask: MaskedRange,
        from: 1,
        to: 12,
        maxLength: 2
      },
      Y: {
        mask: MaskedRange,
        from: 1900,
        to: 9999
      }
    });
    static DEFAULTS = {
      mask: Date,
      pattern: 'd{.}`m{.}`Y',
      format: (date, masked) => {
        if (!date) return '';
        const day = String(date.getDate()).padStart(2, '0');
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const year = date.getFullYear();
        return [day, month, year].join('.');
      },
      parse: (str, masked) => {
        const [day, month, year] = str.split('.').map(Number);
        return new Date(year, month - 1, day);
      }
    };
    static extractPatternOptions(opts) {
      const {
        mask,
        pattern,
        ...patternOpts
      } = opts;
      return {
        ...patternOpts,
        mask: isString(mask) ? mask : pattern
      };
    }

    /** Pattern mask for date according to {@link MaskedDate#format} */

    /** Start date */

    /** End date */

    /** */

    /** Format typed value to string */

    /** Parse string to get typed value */

    constructor(opts) {
      super(MaskedDate.extractPatternOptions({
        ...MaskedDate.DEFAULTS,
        ...opts
      }));
    }
    updateOptions(opts) {
      super.updateOptions(opts);
    }
    _update(opts) {
      const {
        mask,
        pattern,
        blocks,
        ...patternOpts
      } = {
        ...MaskedDate.DEFAULTS,
        ...opts
      };
      const patternBlocks = Object.assign({}, MaskedDate.GET_DEFAULT_BLOCKS());
      // adjust year block
      if (opts.min) patternBlocks.Y.from = opts.min.getFullYear();
      if (opts.max) patternBlocks.Y.to = opts.max.getFullYear();
      if (opts.min && opts.max && patternBlocks.Y.from === patternBlocks.Y.to) {
        patternBlocks.m.from = opts.min.getMonth() + 1;
        patternBlocks.m.to = opts.max.getMonth() + 1;
        if (patternBlocks.m.from === patternBlocks.m.to) {
          patternBlocks.d.from = opts.min.getDate();
          patternBlocks.d.to = opts.max.getDate();
        }
      }
      Object.assign(patternBlocks, this.blocks, blocks);

      // add autofix
      Object.keys(patternBlocks).forEach(bk => {
        const b = patternBlocks[bk];
        if (!('autofix' in b) && 'autofix' in opts) b.autofix = opts.autofix;
      });
      super._update({
        ...patternOpts,
        mask: isString(mask) ? mask : pattern,
        blocks: patternBlocks
      });
    }
    doValidate(flags) {
      const date = this.date;
      return super.doValidate(flags) && (!this.isComplete || this.isDateExist(this.value) && date != null && (this.min == null || this.min <= date) && (this.max == null || date <= this.max));
    }

    /** Checks if date is exists */
    isDateExist(str) {
      return this.format(this.parse(str, this), this).indexOf(str) >= 0;
    }

    /** Parsed Date */
    get date() {
      return this.typedValue;
    }
    set date(date) {
      this.typedValue = date;
    }
    get typedValue() {
      return this.isComplete ? super.typedValue : null;
    }
    set typedValue(value) {
      super.typedValue = value;
    }
    maskEquals(mask) {
      return mask === Date || super.maskEquals(mask);
    }
    optionsIsChanged(opts) {
      return super.optionsIsChanged(MaskedDate.extractPatternOptions(opts));
    }
  }
  IMask.MaskedDate = MaskedDate;

  /** Dynamic mask for choosing appropriate mask in run-time */
  class MaskedDynamic extends Masked {
    static DEFAULTS;

    /** Currently chosen mask */

    /** Currently chosen mask */

    /** Compliled {@link Masked} options */

    /** Chooses {@link Masked} depending on input value */

    constructor(opts) {
      super({
        ...MaskedDynamic.DEFAULTS,
        ...opts
      });
      this.currentMask = undefined;
    }
    updateOptions(opts) {
      super.updateOptions(opts);
    }
    _update(opts) {
      super._update(opts);
      if ('mask' in opts) {
        this.exposeMask = undefined;
        // mask could be totally dynamic with only `dispatch` option
        this.compiledMasks = Array.isArray(opts.mask) ? opts.mask.map(m => {
          const {
            expose,
            ...maskOpts
          } = normalizeOpts(m);
          const masked = createMask({
            overwrite: this._overwrite,
            eager: this._eager,
            skipInvalid: this._skipInvalid,
            ...maskOpts
          });
          if (expose) this.exposeMask = masked;
          return masked;
        }) : [];

        // this.currentMask = this.doDispatch(''); // probably not needed but lets see
      }
    }
    _appendCharRaw(ch, flags) {
      if (flags === void 0) {
        flags = {};
      }
      const details = this._applyDispatch(ch, flags);
      if (this.currentMask) {
        details.aggregate(this.currentMask._appendChar(ch, this.currentMaskFlags(flags)));
      }
      return details;
    }
    _applyDispatch(appended, flags, tail) {
      if (appended === void 0) {
        appended = '';
      }
      if (flags === void 0) {
        flags = {};
      }
      if (tail === void 0) {
        tail = '';
      }
      const prevValueBeforeTail = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._value : this.value;
      const inputValue = this.rawInputValue;
      const insertValue = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._rawInputValue : inputValue;
      const tailValue = inputValue.slice(insertValue.length);
      const prevMask = this.currentMask;
      const details = new ChangeDetails();
      const prevMaskState = prevMask?.state;

      // clone flags to prevent overwriting `_beforeTailState`
      this.currentMask = this.doDispatch(appended, {
        ...flags
      }, tail);

      // restore state after dispatch
      if (this.currentMask) {
        if (this.currentMask !== prevMask) {
          // if mask changed reapply input
          this.currentMask.reset();
          if (insertValue) {
            const d = this.currentMask.append(insertValue, {
              raw: true
            });
            details.tailShift = d.inserted.length - prevValueBeforeTail.length;
          }
          if (tailValue) {
            details.tailShift += this.currentMask.append(tailValue, {
              raw: true,
              tail: true
            }).tailShift;
          }
        } else if (prevMaskState) {
          // Dispatch can do something bad with state, so
          // restore prev mask state
          this.currentMask.state = prevMaskState;
        }
      }
      return details;
    }
    _appendPlaceholder() {
      const details = this._applyDispatch();
      if (this.currentMask) {
        details.aggregate(this.currentMask._appendPlaceholder());
      }
      return details;
    }
    _appendEager() {
      const details = this._applyDispatch();
      if (this.currentMask) {
        details.aggregate(this.currentMask._appendEager());
      }
      return details;
    }
    appendTail(tail) {
      const details = new ChangeDetails();
      if (tail) details.aggregate(this._applyDispatch('', {}, tail));
      return details.aggregate(this.currentMask ? this.currentMask.appendTail(tail) : super.appendTail(tail));
    }
    currentMaskFlags(flags) {
      return {
        ...flags,
        _beforeTailState: flags._beforeTailState?.currentMaskRef === this.currentMask && flags._beforeTailState?.currentMask || flags._beforeTailState
      };
    }
    doDispatch(appended, flags, tail) {
      if (flags === void 0) {
        flags = {};
      }
      if (tail === void 0) {
        tail = '';
      }
      return this.dispatch(appended, this, flags, tail);
    }
    doValidate(flags) {
      return super.doValidate(flags) && (!this.currentMask || this.currentMask.doValidate(this.currentMaskFlags(flags)));
    }
    doPrepare(str, flags) {
      if (flags === void 0) {
        flags = {};
      }
      let [s, details] = super.doPrepare(str, flags);
      if (this.currentMask) {
        let currentDetails;
        [s, currentDetails] = super.doPrepare(s, this.currentMaskFlags(flags));
        details = details.aggregate(currentDetails);
      }
      return [s, details];
    }
    doPrepareChar(str, flags) {
      if (flags === void 0) {
        flags = {};
      }
      let [s, details] = super.doPrepareChar(str, flags);
      if (this.currentMask) {
        let currentDetails;
        [s, currentDetails] = super.doPrepareChar(s, this.currentMaskFlags(flags));
        details = details.aggregate(currentDetails);
      }
      return [s, details];
    }
    reset() {
      this.currentMask?.reset();
      this.compiledMasks.forEach(m => m.reset());
    }
    get value() {
      return this.exposeMask ? this.exposeMask.value : this.currentMask ? this.currentMask.value : '';
    }
    set value(value) {
      if (this.exposeMask) {
        this.exposeMask.value = value;
        this.currentMask = this.exposeMask;
        this._applyDispatch();
      } else super.value = value;
    }
    get unmaskedValue() {
      return this.exposeMask ? this.exposeMask.unmaskedValue : this.currentMask ? this.currentMask.unmaskedValue : '';
    }
    set unmaskedValue(unmaskedValue) {
      if (this.exposeMask) {
        this.exposeMask.unmaskedValue = unmaskedValue;
        this.currentMask = this.exposeMask;
        this._applyDispatch();
      } else super.unmaskedValue = unmaskedValue;
    }
    get typedValue() {
      return this.exposeMask ? this.exposeMask.typedValue : this.currentMask ? this.currentMask.typedValue : '';
    }
    set typedValue(typedValue) {
      if (this.exposeMask) {
        this.exposeMask.typedValue = typedValue;
        this.currentMask = this.exposeMask;
        this._applyDispatch();
        return;
      }
      let unmaskedValue = String(typedValue);

      // double check it
      if (this.currentMask) {
        this.currentMask.typedValue = typedValue;
        unmaskedValue = this.currentMask.unmaskedValue;
      }
      this.unmaskedValue = unmaskedValue;
    }
    get displayValue() {
      return this.currentMask ? this.currentMask.displayValue : '';
    }
    get isComplete() {
      return Boolean(this.currentMask?.isComplete);
    }
    get isFilled() {
      return Boolean(this.currentMask?.isFilled);
    }
    remove(fromPos, toPos) {
      const details = new ChangeDetails();
      if (this.currentMask) {
        details.aggregate(this.currentMask.remove(fromPos, toPos))
        // update with dispatch
        .aggregate(this._applyDispatch());
      }
      return details;
    }
    get state() {
      return {
        ...super.state,
        _rawInputValue: this.rawInputValue,
        compiledMasks: this.compiledMasks.map(m => m.state),
        currentMaskRef: this.currentMask,
        currentMask: this.currentMask?.state
      };
    }
    set state(state) {
      const {
        compiledMasks,
        currentMaskRef,
        currentMask,
        ...maskedState
      } = state;
      if (compiledMasks) this.compiledMasks.forEach((m, mi) => m.state = compiledMasks[mi]);
      if (currentMaskRef != null) {
        this.currentMask = currentMaskRef;
        this.currentMask.state = currentMask;
      }
      super.state = maskedState;
    }
    extractInput(fromPos, toPos, flags) {
      return this.currentMask ? this.currentMask.extractInput(fromPos, toPos, flags) : '';
    }
    extractTail(fromPos, toPos) {
      return this.currentMask ? this.currentMask.extractTail(fromPos, toPos) : super.extractTail(fromPos, toPos);
    }
    doCommit() {
      if (this.currentMask) this.currentMask.doCommit();
      super.doCommit();
    }
    nearestInputPos(cursorPos, direction) {
      return this.currentMask ? this.currentMask.nearestInputPos(cursorPos, direction) : super.nearestInputPos(cursorPos, direction);
    }
    get overwrite() {
      return this.currentMask ? this.currentMask.overwrite : this._overwrite;
    }
    set overwrite(overwrite) {
      this._overwrite = overwrite;
    }
    get eager() {
      return this.currentMask ? this.currentMask.eager : this._eager;
    }
    set eager(eager) {
      this._eager = eager;
    }
    get skipInvalid() {
      return this.currentMask ? this.currentMask.skipInvalid : this._skipInvalid;
    }
    set skipInvalid(skipInvalid) {
      this._skipInvalid = skipInvalid;
    }
    maskEquals(mask) {
      return Array.isArray(mask) ? this.compiledMasks.every((m, mi) => {
        if (!mask[mi]) return;
        const {
          mask: oldMask,
          ...restOpts
        } = mask[mi];
        return objectIncludes(m, restOpts) && m.maskEquals(oldMask);
      }) : super.maskEquals(mask);
    }
    typedValueEquals(value) {
      return Boolean(this.currentMask?.typedValueEquals(value));
    }
  }
  MaskedDynamic.DEFAULTS = {
    dispatch: (appended, masked, flags, tail) => {
      if (!masked.compiledMasks.length) return;
      const inputValue = masked.rawInputValue;

      // simulate input
      const inputs = masked.compiledMasks.map((m, index) => {
        const isCurrent = masked.currentMask === m;
        const startInputPos = isCurrent ? m.displayValue.length : m.nearestInputPos(m.displayValue.length, DIRECTION.FORCE_LEFT);
        if (m.rawInputValue !== inputValue) {
          m.reset();
          m.append(inputValue, {
            raw: true
          });
        } else if (!isCurrent) {
          m.remove(startInputPos);
        }
        m.append(appended, masked.currentMaskFlags(flags));
        m.appendTail(tail);
        return {
          index,
          weight: m.rawInputValue.length,
          totalInputPositions: m.totalInputPositions(0, Math.max(startInputPos, m.nearestInputPos(m.displayValue.length, DIRECTION.FORCE_LEFT)))
        };
      });

      // pop masks with longer values first
      inputs.sort((i1, i2) => i2.weight - i1.weight || i2.totalInputPositions - i1.totalInputPositions);
      return masked.compiledMasks[inputs[0].index];
    }
  };
  IMask.MaskedDynamic = MaskedDynamic;

  /** Pattern which validates enum values */
  class MaskedEnum extends MaskedPattern {
    constructor(opts) {
      super(opts); // mask will be created in _update
    }
    updateOptions(opts) {
      super.updateOptions(opts);
    }
    _update(opts) {
      const {
        enum: _enum,
        ...eopts
      } = opts;
      if (_enum) {
        const lengths = _enum.map(e => e.length);
        const requiredLength = Math.min(...lengths);
        const optionalLength = Math.max(...lengths) - requiredLength;
        eopts.mask = '*'.repeat(requiredLength);
        if (optionalLength) eopts.mask += '[' + '*'.repeat(optionalLength) + ']';
        this.enum = _enum;
      }
      super._update(eopts);
    }
    doValidate(flags) {
      return this.enum.some(e => e.indexOf(this.unmaskedValue) === 0) && super.doValidate(flags);
    }
  }
  IMask.MaskedEnum = MaskedEnum;

  /** Masking by custom Function */
  class MaskedFunction extends Masked {
    /** */

    /** Enable characters overwriting */

    /** */

    /** */

    updateOptions(opts) {
      super.updateOptions(opts);
    }
    _update(opts) {
      super._update({
        ...opts,
        validate: opts.mask
      });
    }
  }
  IMask.MaskedFunction = MaskedFunction;

  /** Number mask */
  class MaskedNumber extends Masked {
    static UNMASKED_RADIX = '.';
    static EMPTY_VALUES = [...Masked.EMPTY_VALUES, 0];
    static DEFAULTS = {
      mask: Number,
      radix: ',',
      thousandsSeparator: '',
      mapToRadix: [MaskedNumber.UNMASKED_RADIX],
      min: Number.MIN_SAFE_INTEGER,
      max: Number.MAX_SAFE_INTEGER,
      scale: 2,
      normalizeZeros: true,
      padFractionalZeros: false,
      parse: Number,
      format: n => n.toLocaleString('en-US', {
        useGrouping: false,
        maximumFractionDigits: 20
      })
    };

    /** Single char */

    /** Single char */

    /** Array of single chars */

    /** */

    /** */

    /** Digits after point */

    /** Flag to remove leading and trailing zeros in the end of editing */

    /** Flag to pad trailing zeros after point in the end of editing */

    /** Enable characters overwriting */

    /** */

    /** */

    /** Format typed value to string */

    /** Parse string to get typed value */

    constructor(opts) {
      super({
        ...MaskedNumber.DEFAULTS,
        ...opts
      });
    }
    updateOptions(opts) {
      super.updateOptions(opts);
    }
    _update(opts) {
      super._update(opts);
      this._updateRegExps();
    }
    _updateRegExps() {
      const start = '^' + (this.allowNegative ? '[+|\\-]?' : '');
      const mid = '\\d*';
      const end = (this.scale ? `(${escapeRegExp(this.radix)}\\d{0,${this.scale}})?` : '') + '$';
      this._numberRegExp = new RegExp(start + mid + end);
      this._mapToRadixRegExp = new RegExp(`[${this.mapToRadix.map(escapeRegExp).join('')}]`, 'g');
      this._thousandsSeparatorRegExp = new RegExp(escapeRegExp(this.thousandsSeparator), 'g');
    }
    _removeThousandsSeparators(value) {
      return value.replace(this._thousandsSeparatorRegExp, '');
    }
    _insertThousandsSeparators(value) {
      // https://stackoverflow.com/questions/2901102/how-to-print-a-number-with-commas-as-thousands-separators-in-javascript
      const parts = value.split(this.radix);
      parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, this.thousandsSeparator);
      return parts.join(this.radix);
    }
    doPrepareChar(ch, flags) {
      if (flags === void 0) {
        flags = {};
      }
      const [prepCh, details] = super.doPrepareChar(this._removeThousandsSeparators(this.scale && this.mapToRadix.length && (
      /*
        radix should be mapped when
        1) input is done from keyboard = flags.input && flags.raw
        2) unmasked value is set = !flags.input && !flags.raw
        and should not be mapped when
        1) value is set = flags.input && !flags.raw
        2) raw value is set = !flags.input && flags.raw
      */
      flags.input && flags.raw || !flags.input && !flags.raw) ? ch.replace(this._mapToRadixRegExp, this.radix) : ch), flags);
      if (ch && !prepCh) details.skip = true;
      if (prepCh && !this.allowPositive && !this.value && prepCh !== '-') details.aggregate(this._appendChar('-'));
      return [prepCh, details];
    }
    _separatorsCount(to, extendOnSeparators) {
      if (extendOnSeparators === void 0) {
        extendOnSeparators = false;
      }
      let count = 0;
      for (let pos = 0; pos < to; ++pos) {
        if (this._value.indexOf(this.thousandsSeparator, pos) === pos) {
          ++count;
          if (extendOnSeparators) to += this.thousandsSeparator.length;
        }
      }
      return count;
    }
    _separatorsCountFromSlice(slice) {
      if (slice === void 0) {
        slice = this._value;
      }
      return this._separatorsCount(this._removeThousandsSeparators(slice).length, true);
    }
    extractInput(fromPos, toPos, flags) {
      if (fromPos === void 0) {
        fromPos = 0;
      }
      if (toPos === void 0) {
        toPos = this.displayValue.length;
      }
      [fromPos, toPos] = this._adjustRangeWithSeparators(fromPos, toPos);
      return this._removeThousandsSeparators(super.extractInput(fromPos, toPos, flags));
    }
    _appendCharRaw(ch, flags) {
      if (flags === void 0) {
        flags = {};
      }
      if (!this.thousandsSeparator) return super._appendCharRaw(ch, flags);
      const prevBeforeTailValue = flags.tail && flags._beforeTailState ? flags._beforeTailState._value : this._value;
      const prevBeforeTailSeparatorsCount = this._separatorsCountFromSlice(prevBeforeTailValue);
      this._value = this._removeThousandsSeparators(this.value);
      const appendDetails = super._appendCharRaw(ch, flags);
      this._value = this._insertThousandsSeparators(this._value);
      const beforeTailValue = flags.tail && flags._beforeTailState ? flags._beforeTailState._value : this._value;
      const beforeTailSeparatorsCount = this._separatorsCountFromSlice(beforeTailValue);
      appendDetails.tailShift += (beforeTailSeparatorsCount - prevBeforeTailSeparatorsCount) * this.thousandsSeparator.length;
      appendDetails.skip = !appendDetails.rawInserted && ch === this.thousandsSeparator;
      return appendDetails;
    }
    _findSeparatorAround(pos) {
      if (this.thousandsSeparator) {
        const searchFrom = pos - this.thousandsSeparator.length + 1;
        const separatorPos = this.value.indexOf(this.thousandsSeparator, searchFrom);
        if (separatorPos <= pos) return separatorPos;
      }
      return -1;
    }
    _adjustRangeWithSeparators(from, to) {
      const separatorAroundFromPos = this._findSeparatorAround(from);
      if (separatorAroundFromPos >= 0) from = separatorAroundFromPos;
      const separatorAroundToPos = this._findSeparatorAround(to);
      if (separatorAroundToPos >= 0) to = separatorAroundToPos + this.thousandsSeparator.length;
      return [from, to];
    }
    remove(fromPos, toPos) {
      if (fromPos === void 0) {
        fromPos = 0;
      }
      if (toPos === void 0) {
        toPos = this.displayValue.length;
      }
      [fromPos, toPos] = this._adjustRangeWithSeparators(fromPos, toPos);
      const valueBeforePos = this.value.slice(0, fromPos);
      const valueAfterPos = this.value.slice(toPos);
      const prevBeforeTailSeparatorsCount = this._separatorsCount(valueBeforePos.length);
      this._value = this._insertThousandsSeparators(this._removeThousandsSeparators(valueBeforePos + valueAfterPos));
      const beforeTailSeparatorsCount = this._separatorsCountFromSlice(valueBeforePos);
      return new ChangeDetails({
        tailShift: (beforeTailSeparatorsCount - prevBeforeTailSeparatorsCount) * this.thousandsSeparator.length
      });
    }
    nearestInputPos(cursorPos, direction) {
      if (!this.thousandsSeparator) return cursorPos;
      switch (direction) {
        case DIRECTION.NONE:
        case DIRECTION.LEFT:
        case DIRECTION.FORCE_LEFT:
          {
            const separatorAtLeftPos = this._findSeparatorAround(cursorPos - 1);
            if (separatorAtLeftPos >= 0) {
              const separatorAtLeftEndPos = separatorAtLeftPos + this.thousandsSeparator.length;
              if (cursorPos < separatorAtLeftEndPos || this.value.length <= separatorAtLeftEndPos || direction === DIRECTION.FORCE_LEFT) {
                return separatorAtLeftPos;
              }
            }
            break;
          }
        case DIRECTION.RIGHT:
        case DIRECTION.FORCE_RIGHT:
          {
            const separatorAtRightPos = this._findSeparatorAround(cursorPos);
            if (separatorAtRightPos >= 0) {
              return separatorAtRightPos + this.thousandsSeparator.length;
            }
          }
      }
      return cursorPos;
    }
    doValidate(flags) {
      // validate as string
      let valid = Boolean(this._removeThousandsSeparators(this.value).match(this._numberRegExp));
      if (valid) {
        // validate as number
        const number = this.number;
        valid = valid && !isNaN(number) && (
        // check min bound for negative values
        this.min == null || this.min >= 0 || this.min <= this.number) && (
        // check max bound for positive values
        this.max == null || this.max <= 0 || this.number <= this.max);
      }
      return valid && super.doValidate(flags);
    }
    doCommit() {
      if (this.value) {
        const number = this.number;
        let validnum = number;

        // check bounds
        if (this.min != null) validnum = Math.max(validnum, this.min);
        if (this.max != null) validnum = Math.min(validnum, this.max);
        if (validnum !== number) this.unmaskedValue = this.format(validnum, this);
        let formatted = this.value;
        if (this.normalizeZeros) formatted = this._normalizeZeros(formatted);
        if (this.padFractionalZeros && this.scale > 0) formatted = this._padFractionalZeros(formatted);
        this._value = formatted;
      }
      super.doCommit();
    }
    _normalizeZeros(value) {
      const parts = this._removeThousandsSeparators(value).split(this.radix);

      // remove leading zeros
      parts[0] = parts[0].replace(/^(\D*)(0*)(\d*)/, (match, sign, zeros, num) => sign + num);
      // add leading zero
      if (value.length && !/\d$/.test(parts[0])) parts[0] = parts[0] + '0';
      if (parts.length > 1) {
        parts[1] = parts[1].replace(/0*$/, ''); // remove trailing zeros
        if (!parts[1].length) parts.length = 1; // remove fractional
      }
      return this._insertThousandsSeparators(parts.join(this.radix));
    }
    _padFractionalZeros(value) {
      if (!value) return value;
      const parts = value.split(this.radix);
      if (parts.length < 2) parts.push('');
      parts[1] = parts[1].padEnd(this.scale, '0');
      return parts.join(this.radix);
    }
    doSkipInvalid(ch, flags, checkTail) {
      if (flags === void 0) {
        flags = {};
      }
      const dropFractional = this.scale === 0 && ch !== this.thousandsSeparator && (ch === this.radix || ch === MaskedNumber.UNMASKED_RADIX || this.mapToRadix.includes(ch));
      return super.doSkipInvalid(ch, flags, checkTail) && !dropFractional;
    }
    get unmaskedValue() {
      return this._removeThousandsSeparators(this._normalizeZeros(this.value)).replace(this.radix, MaskedNumber.UNMASKED_RADIX);
    }
    set unmaskedValue(unmaskedValue) {
      super.unmaskedValue = unmaskedValue;
    }
    get typedValue() {
      return this.parse(this.unmaskedValue, this);
    }
    set typedValue(n) {
      this.rawInputValue = this.format(n, this).replace(MaskedNumber.UNMASKED_RADIX, this.radix);
    }

    /** Parsed Number */
    get number() {
      return this.typedValue;
    }
    set number(number) {
      this.typedValue = number;
    }

    /**
      Is negative allowed
    */
    get allowNegative() {
      return this.min != null && this.min < 0 || this.max != null && this.max < 0;
    }

    /**
      Is positive allowed
    */
    get allowPositive() {
      return this.min != null && this.min > 0 || this.max != null && this.max > 0;
    }
    typedValueEquals(value) {
      // handle  0 -> '' case (typed = 0 even if value = '')
      // for details see https://github.com/uNmAnNeR/imaskjs/issues/134
      return (super.typedValueEquals(value) || MaskedNumber.EMPTY_VALUES.includes(value) && MaskedNumber.EMPTY_VALUES.includes(this.typedValue)) && !(value === 0 && this.value === '');
    }
  }
  IMask.MaskedNumber = MaskedNumber;

  /** Mask pipe source and destination types */
  const PIPE_TYPE = {
    MASKED: 'value',
    UNMASKED: 'unmaskedValue',
    TYPED: 'typedValue'
  };
  /** Creates new pipe function depending on mask type, source and destination options */
  function createPipe(arg, from, to) {
    if (from === void 0) {
      from = PIPE_TYPE.MASKED;
    }
    if (to === void 0) {
      to = PIPE_TYPE.MASKED;
    }
    const masked = createMask(arg);
    return value => masked.runIsolated(m => {
      m[from] = value;
      return m[to];
    });
  }

  /** Pipes value through mask depending on mask type, source and destination options */
  function pipe(value, mask, from, to) {
    return createPipe(mask, from, to)(value);
  }
  IMask.PIPE_TYPE = PIPE_TYPE;
  IMask.createPipe = createPipe;
  IMask.pipe = pipe;

  try {
    globalThis.IMask = IMask;
  } catch {}

  // exports.ChangeDetails = ChangeDetails;
  // exports.ChunksTailDetails = ChunksTailDetails;
  // exports.DIRECTION = DIRECTION;
  // exports.HTMLContenteditableMaskElement = HTMLContenteditableMaskElement;
  // exports.HTMLInputMaskElement = HTMLInputMaskElement;
  // exports.HTMLMaskElement = HTMLMaskElement;
  // exports.InputMask = InputMask;
  // exports.MaskElement = MaskElement;
  // exports.Masked = Masked;
  // exports.MaskedDate = MaskedDate;
  // exports.MaskedDynamic = MaskedDynamic;
  // exports.MaskedEnum = MaskedEnum;
  // exports.MaskedFunction = MaskedFunction;
  // exports.MaskedNumber = MaskedNumber;
  // exports.MaskedPattern = MaskedPattern;
  // exports.MaskedRange = MaskedRange;
  // exports.MaskedRegExp = MaskedRegExp;
  // exports.PIPE_TYPE = PIPE_TYPE;
  // exports.PatternFixedDefinition = PatternFixedDefinition;
  // exports.PatternInputDefinition = PatternInputDefinition;
  // exports.createMask = createMask;
  // exports.createPipe = createPipe;
  // exports.default = IMask;
  // exports.forceDirection = forceDirection;
  // exports.normalizeOpts = normalizeOpts;
  // exports.pipe = pipe;

  // Object.defineProperty(exports, '__esModule', { value: true });

// }));

const CustomPlugins = [
  function formats(node){
    const context = node.props; 
    node.hook.input((value, next) => { 
      if( context.type == 'switch' )
        return next(value === true)
      if( value && context.type.includes('date') && value.includes('Z') ){ 
        let format = ( context.type == 'date' ? 'YYYY-MM-DD': 'YYYY-MM-DD\\THH:mm:ss' ); 
        let newVal = formatDate(value, format, null, (context.attrs.utc || true));
        return next(newVal)
      } 
      return next(value)
    });
  },
  function masks(node){
    const context = node.props; 
    node.hook.input((value, next) => {
      const hasMask = 'masks' in context.attrs || 'masks' in context.attrs;
      if ( hasMask ) { 
        const options = context.attrs['masks'] || context.attrs.masks;
        const maskOptions = typeof options === 'object' && options.mask ? options : { mask: options };
        const masked = IMask.createMask(maskOptions);
        masked.resolve(value); 
        return next(masked.value)
      } else {
        return next(value)
      }
    });
  },
];

const inputByComponent = (comp, type = 'input', props = []) => { 
  return {
    // Node type: input, group, or list.
    type: type,
    // Schema to render (schema object or function that returns an object)
    schema: [],
    // A Vue component to render (use schema _OR_ component, but not both)
    component: comp,
    // (optional) Input specific props the <FormKit> component should accept.
    // should be an array of camelCase strings
    props: props,
    // (optional) Array of functions that receive the node.
    features: [], 
  }
};

const plugin = {
  install (Vue) {
    for (const prop in components) {
      if (components.hasOwnProperty(prop)) {
        const component = components[prop];
        // console.log(`Crud${component.__name}`)
        Vue.component(`Crud${component.__name}`, component);
      }
    }
  }
};

const {
  CodeInput,
  JsonInput,
  // EditorInput,
  // DateRangeInput,
  GridInput,
  FormInput,
  ToggleInput,
  TagsInput,
  RepeaterInput,
  CurrencyInput,
  ObjectInput,
  AutocompleteInput,
  ImageInput,
  DynamicInput,
  MultipleInput,
} = inputs; 
 

const CustomInputs = {
  // 'link': inputByComponent(LinkComponent),
  // 'code': inputByComponent(CodeInput, 'input'),
  // 'json': inputByComponent(JsonInput, 'input'),
  // 'editor': inputByComponent(EditorInput, 'input'),
  // 'daterange': inputByComponent(DateRangeInput, 'input', ['format']), 
  'autocomplete': AutocompleteInput,
  'toggle': inputByComponent(ToggleInput, 'input', ['boolean']),
  'tags': inputByComponent(TagsInput, 'input', ['output']),
  'hasMany': inputByComponent(RepeaterInput, 'list', ['schema','inline']),
  'grid': inputByComponent(GridInput, 'input', ['model','overwrite']), 
  'subform': inputByComponent(FormInput, 'input', ['model','overwrite','resource']), 
  'currency': inputByComponent(CurrencyInput, 'input', ['slots']), 
  'image': ImageInput,
  'dynamic': DynamicInput,
  'multiple': MultipleInput,
  'object': inputByComponent(ObjectInput, 'input', ['slots']), 
};

const Pluggable = plugin;

exports.CustomInputs = CustomInputs;
exports.CustomPlugins = CustomPlugins;
exports.Pluggable = Pluggable;
